// Code generated by ent, DO NOT EDIT.

package ent

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/eslsoft/vocnet/internal/infrastructure/database/ent/userword"
	"github.com/eslsoft/vocnet/internal/infrastructure/database/types"
)

// UserWord is the model entity for the UserWord schema.
type UserWord struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// UserID holds the value of the "user_id" field.
	UserID int64 `json:"user_id,omitempty"`
	// Word holds the value of the "word" field.
	Word string `json:"word,omitempty"`
	// Language holds the value of the "language" field.
	Language string `json:"language,omitempty"`
	// MasteryListen holds the value of the "mastery_listen" field.
	MasteryListen int16 `json:"mastery_listen,omitempty"`
	// MasteryRead holds the value of the "mastery_read" field.
	MasteryRead int16 `json:"mastery_read,omitempty"`
	// MasterySpell holds the value of the "mastery_spell" field.
	MasterySpell int16 `json:"mastery_spell,omitempty"`
	// MasteryPronounce holds the value of the "mastery_pronounce" field.
	MasteryPronounce int16 `json:"mastery_pronounce,omitempty"`
	// MasteryUse holds the value of the "mastery_use" field.
	MasteryUse int16 `json:"mastery_use,omitempty"`
	// MasteryOverall holds the value of the "mastery_overall" field.
	MasteryOverall int32 `json:"mastery_overall,omitempty"`
	// ReviewLastReviewAt holds the value of the "review_last_review_at" field.
	ReviewLastReviewAt *time.Time `json:"review_last_review_at,omitempty"`
	// ReviewNextReviewAt holds the value of the "review_next_review_at" field.
	ReviewNextReviewAt *time.Time `json:"review_next_review_at,omitempty"`
	// ReviewIntervalDays holds the value of the "review_interval_days" field.
	ReviewIntervalDays int32 `json:"review_interval_days,omitempty"`
	// ReviewFailCount holds the value of the "review_fail_count" field.
	ReviewFailCount int32 `json:"review_fail_count,omitempty"`
	// QueryCount holds the value of the "query_count" field.
	QueryCount int64 `json:"query_count,omitempty"`
	// Notes holds the value of the "notes" field.
	Notes *string `json:"notes,omitempty"`
	// Sentences holds the value of the "sentences" field.
	Sentences types.UserSentences `json:"sentences,omitempty"`
	// Relations holds the value of the "relations" field.
	Relations types.UserWordRelations `json:"relations,omitempty"`
	// CreatedBy holds the value of the "created_by" field.
	CreatedBy string `json:"created_by,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt    time.Time `json:"updated_at,omitempty"`
	selectValues sql.SelectValues
}

// scanValues returns the types for scanning values from sql.Rows.
func (*UserWord) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case userword.FieldSentences, userword.FieldRelations:
			values[i] = new([]byte)
		case userword.FieldID, userword.FieldUserID, userword.FieldMasteryListen, userword.FieldMasteryRead, userword.FieldMasterySpell, userword.FieldMasteryPronounce, userword.FieldMasteryUse, userword.FieldMasteryOverall, userword.FieldReviewIntervalDays, userword.FieldReviewFailCount, userword.FieldQueryCount:
			values[i] = new(sql.NullInt64)
		case userword.FieldWord, userword.FieldLanguage, userword.FieldNotes, userword.FieldCreatedBy:
			values[i] = new(sql.NullString)
		case userword.FieldReviewLastReviewAt, userword.FieldReviewNextReviewAt, userword.FieldCreatedAt, userword.FieldUpdatedAt:
			values[i] = new(sql.NullTime)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the UserWord fields.
func (uw *UserWord) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case userword.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			uw.ID = int(value.Int64)
		case userword.FieldUserID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field user_id", values[i])
			} else if value.Valid {
				uw.UserID = value.Int64
			}
		case userword.FieldWord:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field word", values[i])
			} else if value.Valid {
				uw.Word = value.String
			}
		case userword.FieldLanguage:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field language", values[i])
			} else if value.Valid {
				uw.Language = value.String
			}
		case userword.FieldMasteryListen:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field mastery_listen", values[i])
			} else if value.Valid {
				uw.MasteryListen = int16(value.Int64)
			}
		case userword.FieldMasteryRead:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field mastery_read", values[i])
			} else if value.Valid {
				uw.MasteryRead = int16(value.Int64)
			}
		case userword.FieldMasterySpell:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field mastery_spell", values[i])
			} else if value.Valid {
				uw.MasterySpell = int16(value.Int64)
			}
		case userword.FieldMasteryPronounce:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field mastery_pronounce", values[i])
			} else if value.Valid {
				uw.MasteryPronounce = int16(value.Int64)
			}
		case userword.FieldMasteryUse:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field mastery_use", values[i])
			} else if value.Valid {
				uw.MasteryUse = int16(value.Int64)
			}
		case userword.FieldMasteryOverall:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field mastery_overall", values[i])
			} else if value.Valid {
				uw.MasteryOverall = int32(value.Int64)
			}
		case userword.FieldReviewLastReviewAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field review_last_review_at", values[i])
			} else if value.Valid {
				uw.ReviewLastReviewAt = new(time.Time)
				*uw.ReviewLastReviewAt = value.Time
			}
		case userword.FieldReviewNextReviewAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field review_next_review_at", values[i])
			} else if value.Valid {
				uw.ReviewNextReviewAt = new(time.Time)
				*uw.ReviewNextReviewAt = value.Time
			}
		case userword.FieldReviewIntervalDays:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field review_interval_days", values[i])
			} else if value.Valid {
				uw.ReviewIntervalDays = int32(value.Int64)
			}
		case userword.FieldReviewFailCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field review_fail_count", values[i])
			} else if value.Valid {
				uw.ReviewFailCount = int32(value.Int64)
			}
		case userword.FieldQueryCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field query_count", values[i])
			} else if value.Valid {
				uw.QueryCount = value.Int64
			}
		case userword.FieldNotes:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field notes", values[i])
			} else if value.Valid {
				uw.Notes = new(string)
				*uw.Notes = value.String
			}
		case userword.FieldSentences:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field sentences", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &uw.Sentences); err != nil {
					return fmt.Errorf("unmarshal field sentences: %w", err)
				}
			}
		case userword.FieldRelations:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field relations", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &uw.Relations); err != nil {
					return fmt.Errorf("unmarshal field relations: %w", err)
				}
			}
		case userword.FieldCreatedBy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field created_by", values[i])
			} else if value.Valid {
				uw.CreatedBy = value.String
			}
		case userword.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				uw.CreatedAt = value.Time
			}
		case userword.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				uw.UpdatedAt = value.Time
			}
		default:
			uw.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the UserWord.
// This includes values selected through modifiers, order, etc.
func (uw *UserWord) Value(name string) (ent.Value, error) {
	return uw.selectValues.Get(name)
}

// Update returns a builder for updating this UserWord.
// Note that you need to call UserWord.Unwrap() before calling this method if this UserWord
// was returned from a transaction, and the transaction was committed or rolled back.
func (uw *UserWord) Update() *UserWordUpdateOne {
	return NewUserWordClient(uw.config).UpdateOne(uw)
}

// Unwrap unwraps the UserWord entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (uw *UserWord) Unwrap() *UserWord {
	_tx, ok := uw.config.driver.(*txDriver)
	if !ok {
		panic("ent: UserWord is not a transactional entity")
	}
	uw.config.driver = _tx.drv
	return uw
}

// String implements the fmt.Stringer.
func (uw *UserWord) String() string {
	var builder strings.Builder
	builder.WriteString("UserWord(")
	builder.WriteString(fmt.Sprintf("id=%v, ", uw.ID))
	builder.WriteString("user_id=")
	builder.WriteString(fmt.Sprintf("%v", uw.UserID))
	builder.WriteString(", ")
	builder.WriteString("word=")
	builder.WriteString(uw.Word)
	builder.WriteString(", ")
	builder.WriteString("language=")
	builder.WriteString(uw.Language)
	builder.WriteString(", ")
	builder.WriteString("mastery_listen=")
	builder.WriteString(fmt.Sprintf("%v", uw.MasteryListen))
	builder.WriteString(", ")
	builder.WriteString("mastery_read=")
	builder.WriteString(fmt.Sprintf("%v", uw.MasteryRead))
	builder.WriteString(", ")
	builder.WriteString("mastery_spell=")
	builder.WriteString(fmt.Sprintf("%v", uw.MasterySpell))
	builder.WriteString(", ")
	builder.WriteString("mastery_pronounce=")
	builder.WriteString(fmt.Sprintf("%v", uw.MasteryPronounce))
	builder.WriteString(", ")
	builder.WriteString("mastery_use=")
	builder.WriteString(fmt.Sprintf("%v", uw.MasteryUse))
	builder.WriteString(", ")
	builder.WriteString("mastery_overall=")
	builder.WriteString(fmt.Sprintf("%v", uw.MasteryOverall))
	builder.WriteString(", ")
	if v := uw.ReviewLastReviewAt; v != nil {
		builder.WriteString("review_last_review_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := uw.ReviewNextReviewAt; v != nil {
		builder.WriteString("review_next_review_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	builder.WriteString("review_interval_days=")
	builder.WriteString(fmt.Sprintf("%v", uw.ReviewIntervalDays))
	builder.WriteString(", ")
	builder.WriteString("review_fail_count=")
	builder.WriteString(fmt.Sprintf("%v", uw.ReviewFailCount))
	builder.WriteString(", ")
	builder.WriteString("query_count=")
	builder.WriteString(fmt.Sprintf("%v", uw.QueryCount))
	builder.WriteString(", ")
	if v := uw.Notes; v != nil {
		builder.WriteString("notes=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("sentences=")
	builder.WriteString(fmt.Sprintf("%v", uw.Sentences))
	builder.WriteString(", ")
	builder.WriteString("relations=")
	builder.WriteString(fmt.Sprintf("%v", uw.Relations))
	builder.WriteString(", ")
	builder.WriteString("created_by=")
	builder.WriteString(uw.CreatedBy)
	builder.WriteString(", ")
	builder.WriteString("created_at=")
	builder.WriteString(uw.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(uw.UpdatedAt.Format(time.ANSIC))
	builder.WriteByte(')')
	return builder.String()
}

// UserWords is a parsable slice of UserWord.
type UserWords []*UserWord
