// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/eslsoft/vocnet/internal/infrastructure/database/ent/predicate"
	"github.com/eslsoft/vocnet/internal/infrastructure/database/ent/userword"
	"github.com/eslsoft/vocnet/internal/infrastructure/database/ent/word"
	"github.com/eslsoft/vocnet/internal/infrastructure/database/types"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeUserWord = "UserWord"
	TypeWord     = "Word"
)

// UserWordMutation represents an operation that mutates the UserWord nodes in the graph.
type UserWordMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	user_id                 *int64
	adduser_id              *int64
	word                    *string
	language                *string
	mastery_listen          *int16
	addmastery_listen       *int16
	mastery_read            *int16
	addmastery_read         *int16
	mastery_spell           *int16
	addmastery_spell        *int16
	mastery_pronounce       *int16
	addmastery_pronounce    *int16
	mastery_use             *int16
	addmastery_use          *int16
	mastery_overall         *int32
	addmastery_overall      *int32
	review_last_review_at   *time.Time
	review_next_review_at   *time.Time
	review_interval_days    *int32
	addreview_interval_days *int32
	review_fail_count       *int32
	addreview_fail_count    *int32
	query_count             *int64
	addquery_count          *int64
	notes                   *string
	sentences               *types.UserSentences
	appendsentences         types.UserSentences
	relations               *types.UserWordRelations
	appendrelations         types.UserWordRelations
	created_by              *string
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*UserWord, error)
	predicates              []predicate.UserWord
}

var _ ent.Mutation = (*UserWordMutation)(nil)

// userwordOption allows management of the mutation configuration using functional options.
type userwordOption func(*UserWordMutation)

// newUserWordMutation creates new mutation for the UserWord entity.
func newUserWordMutation(c config, op Op, opts ...userwordOption) *UserWordMutation {
	m := &UserWordMutation{
		config:        c,
		op:            op,
		typ:           TypeUserWord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserWordID sets the ID field of the mutation.
func withUserWordID(id int) userwordOption {
	return func(m *UserWordMutation) {
		var (
			err   error
			once  sync.Once
			value *UserWord
		)
		m.oldValue = func(ctx context.Context) (*UserWord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserWord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserWord sets the old UserWord of the mutation.
func withUserWord(node *UserWord) userwordOption {
	return func(m *UserWordMutation) {
		m.oldValue = func(context.Context) (*UserWord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserWordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserWordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserWordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserWordMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserWord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UserWordMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserWordMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserWord entity.
// If the UserWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWordMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *UserWordMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *UserWordMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserWordMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetWord sets the "word" field.
func (m *UserWordMutation) SetWord(s string) {
	m.word = &s
}

// Word returns the value of the "word" field in the mutation.
func (m *UserWordMutation) Word() (r string, exists bool) {
	v := m.word
	if v == nil {
		return
	}
	return *v, true
}

// OldWord returns the old "word" field's value of the UserWord entity.
// If the UserWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWordMutation) OldWord(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWord is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWord requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWord: %w", err)
	}
	return oldValue.Word, nil
}

// ResetWord resets all changes to the "word" field.
func (m *UserWordMutation) ResetWord() {
	m.word = nil
}

// SetLanguage sets the "language" field.
func (m *UserWordMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *UserWordMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the UserWord entity.
// If the UserWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWordMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage resets all changes to the "language" field.
func (m *UserWordMutation) ResetLanguage() {
	m.language = nil
}

// SetMasteryListen sets the "mastery_listen" field.
func (m *UserWordMutation) SetMasteryListen(i int16) {
	m.mastery_listen = &i
	m.addmastery_listen = nil
}

// MasteryListen returns the value of the "mastery_listen" field in the mutation.
func (m *UserWordMutation) MasteryListen() (r int16, exists bool) {
	v := m.mastery_listen
	if v == nil {
		return
	}
	return *v, true
}

// OldMasteryListen returns the old "mastery_listen" field's value of the UserWord entity.
// If the UserWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWordMutation) OldMasteryListen(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMasteryListen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMasteryListen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMasteryListen: %w", err)
	}
	return oldValue.MasteryListen, nil
}

// AddMasteryListen adds i to the "mastery_listen" field.
func (m *UserWordMutation) AddMasteryListen(i int16) {
	if m.addmastery_listen != nil {
		*m.addmastery_listen += i
	} else {
		m.addmastery_listen = &i
	}
}

// AddedMasteryListen returns the value that was added to the "mastery_listen" field in this mutation.
func (m *UserWordMutation) AddedMasteryListen() (r int16, exists bool) {
	v := m.addmastery_listen
	if v == nil {
		return
	}
	return *v, true
}

// ResetMasteryListen resets all changes to the "mastery_listen" field.
func (m *UserWordMutation) ResetMasteryListen() {
	m.mastery_listen = nil
	m.addmastery_listen = nil
}

// SetMasteryRead sets the "mastery_read" field.
func (m *UserWordMutation) SetMasteryRead(i int16) {
	m.mastery_read = &i
	m.addmastery_read = nil
}

// MasteryRead returns the value of the "mastery_read" field in the mutation.
func (m *UserWordMutation) MasteryRead() (r int16, exists bool) {
	v := m.mastery_read
	if v == nil {
		return
	}
	return *v, true
}

// OldMasteryRead returns the old "mastery_read" field's value of the UserWord entity.
// If the UserWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWordMutation) OldMasteryRead(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMasteryRead is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMasteryRead requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMasteryRead: %w", err)
	}
	return oldValue.MasteryRead, nil
}

// AddMasteryRead adds i to the "mastery_read" field.
func (m *UserWordMutation) AddMasteryRead(i int16) {
	if m.addmastery_read != nil {
		*m.addmastery_read += i
	} else {
		m.addmastery_read = &i
	}
}

// AddedMasteryRead returns the value that was added to the "mastery_read" field in this mutation.
func (m *UserWordMutation) AddedMasteryRead() (r int16, exists bool) {
	v := m.addmastery_read
	if v == nil {
		return
	}
	return *v, true
}

// ResetMasteryRead resets all changes to the "mastery_read" field.
func (m *UserWordMutation) ResetMasteryRead() {
	m.mastery_read = nil
	m.addmastery_read = nil
}

// SetMasterySpell sets the "mastery_spell" field.
func (m *UserWordMutation) SetMasterySpell(i int16) {
	m.mastery_spell = &i
	m.addmastery_spell = nil
}

// MasterySpell returns the value of the "mastery_spell" field in the mutation.
func (m *UserWordMutation) MasterySpell() (r int16, exists bool) {
	v := m.mastery_spell
	if v == nil {
		return
	}
	return *v, true
}

// OldMasterySpell returns the old "mastery_spell" field's value of the UserWord entity.
// If the UserWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWordMutation) OldMasterySpell(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMasterySpell is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMasterySpell requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMasterySpell: %w", err)
	}
	return oldValue.MasterySpell, nil
}

// AddMasterySpell adds i to the "mastery_spell" field.
func (m *UserWordMutation) AddMasterySpell(i int16) {
	if m.addmastery_spell != nil {
		*m.addmastery_spell += i
	} else {
		m.addmastery_spell = &i
	}
}

// AddedMasterySpell returns the value that was added to the "mastery_spell" field in this mutation.
func (m *UserWordMutation) AddedMasterySpell() (r int16, exists bool) {
	v := m.addmastery_spell
	if v == nil {
		return
	}
	return *v, true
}

// ResetMasterySpell resets all changes to the "mastery_spell" field.
func (m *UserWordMutation) ResetMasterySpell() {
	m.mastery_spell = nil
	m.addmastery_spell = nil
}

// SetMasteryPronounce sets the "mastery_pronounce" field.
func (m *UserWordMutation) SetMasteryPronounce(i int16) {
	m.mastery_pronounce = &i
	m.addmastery_pronounce = nil
}

// MasteryPronounce returns the value of the "mastery_pronounce" field in the mutation.
func (m *UserWordMutation) MasteryPronounce() (r int16, exists bool) {
	v := m.mastery_pronounce
	if v == nil {
		return
	}
	return *v, true
}

// OldMasteryPronounce returns the old "mastery_pronounce" field's value of the UserWord entity.
// If the UserWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWordMutation) OldMasteryPronounce(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMasteryPronounce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMasteryPronounce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMasteryPronounce: %w", err)
	}
	return oldValue.MasteryPronounce, nil
}

// AddMasteryPronounce adds i to the "mastery_pronounce" field.
func (m *UserWordMutation) AddMasteryPronounce(i int16) {
	if m.addmastery_pronounce != nil {
		*m.addmastery_pronounce += i
	} else {
		m.addmastery_pronounce = &i
	}
}

// AddedMasteryPronounce returns the value that was added to the "mastery_pronounce" field in this mutation.
func (m *UserWordMutation) AddedMasteryPronounce() (r int16, exists bool) {
	v := m.addmastery_pronounce
	if v == nil {
		return
	}
	return *v, true
}

// ResetMasteryPronounce resets all changes to the "mastery_pronounce" field.
func (m *UserWordMutation) ResetMasteryPronounce() {
	m.mastery_pronounce = nil
	m.addmastery_pronounce = nil
}

// SetMasteryUse sets the "mastery_use" field.
func (m *UserWordMutation) SetMasteryUse(i int16) {
	m.mastery_use = &i
	m.addmastery_use = nil
}

// MasteryUse returns the value of the "mastery_use" field in the mutation.
func (m *UserWordMutation) MasteryUse() (r int16, exists bool) {
	v := m.mastery_use
	if v == nil {
		return
	}
	return *v, true
}

// OldMasteryUse returns the old "mastery_use" field's value of the UserWord entity.
// If the UserWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWordMutation) OldMasteryUse(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMasteryUse is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMasteryUse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMasteryUse: %w", err)
	}
	return oldValue.MasteryUse, nil
}

// AddMasteryUse adds i to the "mastery_use" field.
func (m *UserWordMutation) AddMasteryUse(i int16) {
	if m.addmastery_use != nil {
		*m.addmastery_use += i
	} else {
		m.addmastery_use = &i
	}
}

// AddedMasteryUse returns the value that was added to the "mastery_use" field in this mutation.
func (m *UserWordMutation) AddedMasteryUse() (r int16, exists bool) {
	v := m.addmastery_use
	if v == nil {
		return
	}
	return *v, true
}

// ResetMasteryUse resets all changes to the "mastery_use" field.
func (m *UserWordMutation) ResetMasteryUse() {
	m.mastery_use = nil
	m.addmastery_use = nil
}

// SetMasteryOverall sets the "mastery_overall" field.
func (m *UserWordMutation) SetMasteryOverall(i int32) {
	m.mastery_overall = &i
	m.addmastery_overall = nil
}

// MasteryOverall returns the value of the "mastery_overall" field in the mutation.
func (m *UserWordMutation) MasteryOverall() (r int32, exists bool) {
	v := m.mastery_overall
	if v == nil {
		return
	}
	return *v, true
}

// OldMasteryOverall returns the old "mastery_overall" field's value of the UserWord entity.
// If the UserWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWordMutation) OldMasteryOverall(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMasteryOverall is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMasteryOverall requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMasteryOverall: %w", err)
	}
	return oldValue.MasteryOverall, nil
}

// AddMasteryOverall adds i to the "mastery_overall" field.
func (m *UserWordMutation) AddMasteryOverall(i int32) {
	if m.addmastery_overall != nil {
		*m.addmastery_overall += i
	} else {
		m.addmastery_overall = &i
	}
}

// AddedMasteryOverall returns the value that was added to the "mastery_overall" field in this mutation.
func (m *UserWordMutation) AddedMasteryOverall() (r int32, exists bool) {
	v := m.addmastery_overall
	if v == nil {
		return
	}
	return *v, true
}

// ResetMasteryOverall resets all changes to the "mastery_overall" field.
func (m *UserWordMutation) ResetMasteryOverall() {
	m.mastery_overall = nil
	m.addmastery_overall = nil
}

// SetReviewLastReviewAt sets the "review_last_review_at" field.
func (m *UserWordMutation) SetReviewLastReviewAt(t time.Time) {
	m.review_last_review_at = &t
}

// ReviewLastReviewAt returns the value of the "review_last_review_at" field in the mutation.
func (m *UserWordMutation) ReviewLastReviewAt() (r time.Time, exists bool) {
	v := m.review_last_review_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewLastReviewAt returns the old "review_last_review_at" field's value of the UserWord entity.
// If the UserWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWordMutation) OldReviewLastReviewAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewLastReviewAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewLastReviewAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewLastReviewAt: %w", err)
	}
	return oldValue.ReviewLastReviewAt, nil
}

// ClearReviewLastReviewAt clears the value of the "review_last_review_at" field.
func (m *UserWordMutation) ClearReviewLastReviewAt() {
	m.review_last_review_at = nil
	m.clearedFields[userword.FieldReviewLastReviewAt] = struct{}{}
}

// ReviewLastReviewAtCleared returns if the "review_last_review_at" field was cleared in this mutation.
func (m *UserWordMutation) ReviewLastReviewAtCleared() bool {
	_, ok := m.clearedFields[userword.FieldReviewLastReviewAt]
	return ok
}

// ResetReviewLastReviewAt resets all changes to the "review_last_review_at" field.
func (m *UserWordMutation) ResetReviewLastReviewAt() {
	m.review_last_review_at = nil
	delete(m.clearedFields, userword.FieldReviewLastReviewAt)
}

// SetReviewNextReviewAt sets the "review_next_review_at" field.
func (m *UserWordMutation) SetReviewNextReviewAt(t time.Time) {
	m.review_next_review_at = &t
}

// ReviewNextReviewAt returns the value of the "review_next_review_at" field in the mutation.
func (m *UserWordMutation) ReviewNextReviewAt() (r time.Time, exists bool) {
	v := m.review_next_review_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewNextReviewAt returns the old "review_next_review_at" field's value of the UserWord entity.
// If the UserWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWordMutation) OldReviewNextReviewAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewNextReviewAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewNextReviewAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewNextReviewAt: %w", err)
	}
	return oldValue.ReviewNextReviewAt, nil
}

// ClearReviewNextReviewAt clears the value of the "review_next_review_at" field.
func (m *UserWordMutation) ClearReviewNextReviewAt() {
	m.review_next_review_at = nil
	m.clearedFields[userword.FieldReviewNextReviewAt] = struct{}{}
}

// ReviewNextReviewAtCleared returns if the "review_next_review_at" field was cleared in this mutation.
func (m *UserWordMutation) ReviewNextReviewAtCleared() bool {
	_, ok := m.clearedFields[userword.FieldReviewNextReviewAt]
	return ok
}

// ResetReviewNextReviewAt resets all changes to the "review_next_review_at" field.
func (m *UserWordMutation) ResetReviewNextReviewAt() {
	m.review_next_review_at = nil
	delete(m.clearedFields, userword.FieldReviewNextReviewAt)
}

// SetReviewIntervalDays sets the "review_interval_days" field.
func (m *UserWordMutation) SetReviewIntervalDays(i int32) {
	m.review_interval_days = &i
	m.addreview_interval_days = nil
}

// ReviewIntervalDays returns the value of the "review_interval_days" field in the mutation.
func (m *UserWordMutation) ReviewIntervalDays() (r int32, exists bool) {
	v := m.review_interval_days
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewIntervalDays returns the old "review_interval_days" field's value of the UserWord entity.
// If the UserWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWordMutation) OldReviewIntervalDays(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewIntervalDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewIntervalDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewIntervalDays: %w", err)
	}
	return oldValue.ReviewIntervalDays, nil
}

// AddReviewIntervalDays adds i to the "review_interval_days" field.
func (m *UserWordMutation) AddReviewIntervalDays(i int32) {
	if m.addreview_interval_days != nil {
		*m.addreview_interval_days += i
	} else {
		m.addreview_interval_days = &i
	}
}

// AddedReviewIntervalDays returns the value that was added to the "review_interval_days" field in this mutation.
func (m *UserWordMutation) AddedReviewIntervalDays() (r int32, exists bool) {
	v := m.addreview_interval_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetReviewIntervalDays resets all changes to the "review_interval_days" field.
func (m *UserWordMutation) ResetReviewIntervalDays() {
	m.review_interval_days = nil
	m.addreview_interval_days = nil
}

// SetReviewFailCount sets the "review_fail_count" field.
func (m *UserWordMutation) SetReviewFailCount(i int32) {
	m.review_fail_count = &i
	m.addreview_fail_count = nil
}

// ReviewFailCount returns the value of the "review_fail_count" field in the mutation.
func (m *UserWordMutation) ReviewFailCount() (r int32, exists bool) {
	v := m.review_fail_count
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewFailCount returns the old "review_fail_count" field's value of the UserWord entity.
// If the UserWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWordMutation) OldReviewFailCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewFailCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewFailCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewFailCount: %w", err)
	}
	return oldValue.ReviewFailCount, nil
}

// AddReviewFailCount adds i to the "review_fail_count" field.
func (m *UserWordMutation) AddReviewFailCount(i int32) {
	if m.addreview_fail_count != nil {
		*m.addreview_fail_count += i
	} else {
		m.addreview_fail_count = &i
	}
}

// AddedReviewFailCount returns the value that was added to the "review_fail_count" field in this mutation.
func (m *UserWordMutation) AddedReviewFailCount() (r int32, exists bool) {
	v := m.addreview_fail_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetReviewFailCount resets all changes to the "review_fail_count" field.
func (m *UserWordMutation) ResetReviewFailCount() {
	m.review_fail_count = nil
	m.addreview_fail_count = nil
}

// SetQueryCount sets the "query_count" field.
func (m *UserWordMutation) SetQueryCount(i int64) {
	m.query_count = &i
	m.addquery_count = nil
}

// QueryCount returns the value of the "query_count" field in the mutation.
func (m *UserWordMutation) QueryCount() (r int64, exists bool) {
	v := m.query_count
	if v == nil {
		return
	}
	return *v, true
}

// OldQueryCount returns the old "query_count" field's value of the UserWord entity.
// If the UserWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWordMutation) OldQueryCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQueryCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQueryCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQueryCount: %w", err)
	}
	return oldValue.QueryCount, nil
}

// AddQueryCount adds i to the "query_count" field.
func (m *UserWordMutation) AddQueryCount(i int64) {
	if m.addquery_count != nil {
		*m.addquery_count += i
	} else {
		m.addquery_count = &i
	}
}

// AddedQueryCount returns the value that was added to the "query_count" field in this mutation.
func (m *UserWordMutation) AddedQueryCount() (r int64, exists bool) {
	v := m.addquery_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetQueryCount resets all changes to the "query_count" field.
func (m *UserWordMutation) ResetQueryCount() {
	m.query_count = nil
	m.addquery_count = nil
}

// SetNotes sets the "notes" field.
func (m *UserWordMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *UserWordMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the UserWord entity.
// If the UserWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWordMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *UserWordMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[userword.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *UserWordMutation) NotesCleared() bool {
	_, ok := m.clearedFields[userword.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *UserWordMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, userword.FieldNotes)
}

// SetSentences sets the "sentences" field.
func (m *UserWordMutation) SetSentences(ts types.UserSentences) {
	m.sentences = &ts
	m.appendsentences = nil
}

// Sentences returns the value of the "sentences" field in the mutation.
func (m *UserWordMutation) Sentences() (r types.UserSentences, exists bool) {
	v := m.sentences
	if v == nil {
		return
	}
	return *v, true
}

// OldSentences returns the old "sentences" field's value of the UserWord entity.
// If the UserWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWordMutation) OldSentences(ctx context.Context) (v types.UserSentences, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentences is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentences requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentences: %w", err)
	}
	return oldValue.Sentences, nil
}

// AppendSentences adds ts to the "sentences" field.
func (m *UserWordMutation) AppendSentences(ts types.UserSentences) {
	m.appendsentences = append(m.appendsentences, ts...)
}

// AppendedSentences returns the list of values that were appended to the "sentences" field in this mutation.
func (m *UserWordMutation) AppendedSentences() (types.UserSentences, bool) {
	if len(m.appendsentences) == 0 {
		return nil, false
	}
	return m.appendsentences, true
}

// ResetSentences resets all changes to the "sentences" field.
func (m *UserWordMutation) ResetSentences() {
	m.sentences = nil
	m.appendsentences = nil
}

// SetRelations sets the "relations" field.
func (m *UserWordMutation) SetRelations(twr types.UserWordRelations) {
	m.relations = &twr
	m.appendrelations = nil
}

// Relations returns the value of the "relations" field in the mutation.
func (m *UserWordMutation) Relations() (r types.UserWordRelations, exists bool) {
	v := m.relations
	if v == nil {
		return
	}
	return *v, true
}

// OldRelations returns the old "relations" field's value of the UserWord entity.
// If the UserWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWordMutation) OldRelations(ctx context.Context) (v types.UserWordRelations, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelations: %w", err)
	}
	return oldValue.Relations, nil
}

// AppendRelations adds twr to the "relations" field.
func (m *UserWordMutation) AppendRelations(twr types.UserWordRelations) {
	m.appendrelations = append(m.appendrelations, twr...)
}

// AppendedRelations returns the list of values that were appended to the "relations" field in this mutation.
func (m *UserWordMutation) AppendedRelations() (types.UserWordRelations, bool) {
	if len(m.appendrelations) == 0 {
		return nil, false
	}
	return m.appendrelations, true
}

// ResetRelations resets all changes to the "relations" field.
func (m *UserWordMutation) ResetRelations() {
	m.relations = nil
	m.appendrelations = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *UserWordMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserWordMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UserWord entity.
// If the UserWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWordMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserWordMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserWordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserWordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserWord entity.
// If the UserWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserWordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserWordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserWordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserWord entity.
// If the UserWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserWordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserWordMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the UserWordMutation builder.
func (m *UserWordMutation) Where(ps ...predicate.UserWord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserWordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserWordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserWord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserWordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserWordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserWord).
func (m *UserWordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserWordMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.user_id != nil {
		fields = append(fields, userword.FieldUserID)
	}
	if m.word != nil {
		fields = append(fields, userword.FieldWord)
	}
	if m.language != nil {
		fields = append(fields, userword.FieldLanguage)
	}
	if m.mastery_listen != nil {
		fields = append(fields, userword.FieldMasteryListen)
	}
	if m.mastery_read != nil {
		fields = append(fields, userword.FieldMasteryRead)
	}
	if m.mastery_spell != nil {
		fields = append(fields, userword.FieldMasterySpell)
	}
	if m.mastery_pronounce != nil {
		fields = append(fields, userword.FieldMasteryPronounce)
	}
	if m.mastery_use != nil {
		fields = append(fields, userword.FieldMasteryUse)
	}
	if m.mastery_overall != nil {
		fields = append(fields, userword.FieldMasteryOverall)
	}
	if m.review_last_review_at != nil {
		fields = append(fields, userword.FieldReviewLastReviewAt)
	}
	if m.review_next_review_at != nil {
		fields = append(fields, userword.FieldReviewNextReviewAt)
	}
	if m.review_interval_days != nil {
		fields = append(fields, userword.FieldReviewIntervalDays)
	}
	if m.review_fail_count != nil {
		fields = append(fields, userword.FieldReviewFailCount)
	}
	if m.query_count != nil {
		fields = append(fields, userword.FieldQueryCount)
	}
	if m.notes != nil {
		fields = append(fields, userword.FieldNotes)
	}
	if m.sentences != nil {
		fields = append(fields, userword.FieldSentences)
	}
	if m.relations != nil {
		fields = append(fields, userword.FieldRelations)
	}
	if m.created_by != nil {
		fields = append(fields, userword.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, userword.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userword.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserWordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userword.FieldUserID:
		return m.UserID()
	case userword.FieldWord:
		return m.Word()
	case userword.FieldLanguage:
		return m.Language()
	case userword.FieldMasteryListen:
		return m.MasteryListen()
	case userword.FieldMasteryRead:
		return m.MasteryRead()
	case userword.FieldMasterySpell:
		return m.MasterySpell()
	case userword.FieldMasteryPronounce:
		return m.MasteryPronounce()
	case userword.FieldMasteryUse:
		return m.MasteryUse()
	case userword.FieldMasteryOverall:
		return m.MasteryOverall()
	case userword.FieldReviewLastReviewAt:
		return m.ReviewLastReviewAt()
	case userword.FieldReviewNextReviewAt:
		return m.ReviewNextReviewAt()
	case userword.FieldReviewIntervalDays:
		return m.ReviewIntervalDays()
	case userword.FieldReviewFailCount:
		return m.ReviewFailCount()
	case userword.FieldQueryCount:
		return m.QueryCount()
	case userword.FieldNotes:
		return m.Notes()
	case userword.FieldSentences:
		return m.Sentences()
	case userword.FieldRelations:
		return m.Relations()
	case userword.FieldCreatedBy:
		return m.CreatedBy()
	case userword.FieldCreatedAt:
		return m.CreatedAt()
	case userword.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserWordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userword.FieldUserID:
		return m.OldUserID(ctx)
	case userword.FieldWord:
		return m.OldWord(ctx)
	case userword.FieldLanguage:
		return m.OldLanguage(ctx)
	case userword.FieldMasteryListen:
		return m.OldMasteryListen(ctx)
	case userword.FieldMasteryRead:
		return m.OldMasteryRead(ctx)
	case userword.FieldMasterySpell:
		return m.OldMasterySpell(ctx)
	case userword.FieldMasteryPronounce:
		return m.OldMasteryPronounce(ctx)
	case userword.FieldMasteryUse:
		return m.OldMasteryUse(ctx)
	case userword.FieldMasteryOverall:
		return m.OldMasteryOverall(ctx)
	case userword.FieldReviewLastReviewAt:
		return m.OldReviewLastReviewAt(ctx)
	case userword.FieldReviewNextReviewAt:
		return m.OldReviewNextReviewAt(ctx)
	case userword.FieldReviewIntervalDays:
		return m.OldReviewIntervalDays(ctx)
	case userword.FieldReviewFailCount:
		return m.OldReviewFailCount(ctx)
	case userword.FieldQueryCount:
		return m.OldQueryCount(ctx)
	case userword.FieldNotes:
		return m.OldNotes(ctx)
	case userword.FieldSentences:
		return m.OldSentences(ctx)
	case userword.FieldRelations:
		return m.OldRelations(ctx)
	case userword.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case userword.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userword.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserWord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserWordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userword.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userword.FieldWord:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWord(v)
		return nil
	case userword.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case userword.FieldMasteryListen:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMasteryListen(v)
		return nil
	case userword.FieldMasteryRead:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMasteryRead(v)
		return nil
	case userword.FieldMasterySpell:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMasterySpell(v)
		return nil
	case userword.FieldMasteryPronounce:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMasteryPronounce(v)
		return nil
	case userword.FieldMasteryUse:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMasteryUse(v)
		return nil
	case userword.FieldMasteryOverall:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMasteryOverall(v)
		return nil
	case userword.FieldReviewLastReviewAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewLastReviewAt(v)
		return nil
	case userword.FieldReviewNextReviewAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewNextReviewAt(v)
		return nil
	case userword.FieldReviewIntervalDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewIntervalDays(v)
		return nil
	case userword.FieldReviewFailCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewFailCount(v)
		return nil
	case userword.FieldQueryCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQueryCount(v)
		return nil
	case userword.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case userword.FieldSentences:
		v, ok := value.(types.UserSentences)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentences(v)
		return nil
	case userword.FieldRelations:
		v, ok := value.(types.UserWordRelations)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelations(v)
		return nil
	case userword.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case userword.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userword.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserWord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserWordMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, userword.FieldUserID)
	}
	if m.addmastery_listen != nil {
		fields = append(fields, userword.FieldMasteryListen)
	}
	if m.addmastery_read != nil {
		fields = append(fields, userword.FieldMasteryRead)
	}
	if m.addmastery_spell != nil {
		fields = append(fields, userword.FieldMasterySpell)
	}
	if m.addmastery_pronounce != nil {
		fields = append(fields, userword.FieldMasteryPronounce)
	}
	if m.addmastery_use != nil {
		fields = append(fields, userword.FieldMasteryUse)
	}
	if m.addmastery_overall != nil {
		fields = append(fields, userword.FieldMasteryOverall)
	}
	if m.addreview_interval_days != nil {
		fields = append(fields, userword.FieldReviewIntervalDays)
	}
	if m.addreview_fail_count != nil {
		fields = append(fields, userword.FieldReviewFailCount)
	}
	if m.addquery_count != nil {
		fields = append(fields, userword.FieldQueryCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserWordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userword.FieldUserID:
		return m.AddedUserID()
	case userword.FieldMasteryListen:
		return m.AddedMasteryListen()
	case userword.FieldMasteryRead:
		return m.AddedMasteryRead()
	case userword.FieldMasterySpell:
		return m.AddedMasterySpell()
	case userword.FieldMasteryPronounce:
		return m.AddedMasteryPronounce()
	case userword.FieldMasteryUse:
		return m.AddedMasteryUse()
	case userword.FieldMasteryOverall:
		return m.AddedMasteryOverall()
	case userword.FieldReviewIntervalDays:
		return m.AddedReviewIntervalDays()
	case userword.FieldReviewFailCount:
		return m.AddedReviewFailCount()
	case userword.FieldQueryCount:
		return m.AddedQueryCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserWordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userword.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case userword.FieldMasteryListen:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMasteryListen(v)
		return nil
	case userword.FieldMasteryRead:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMasteryRead(v)
		return nil
	case userword.FieldMasterySpell:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMasterySpell(v)
		return nil
	case userword.FieldMasteryPronounce:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMasteryPronounce(v)
		return nil
	case userword.FieldMasteryUse:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMasteryUse(v)
		return nil
	case userword.FieldMasteryOverall:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMasteryOverall(v)
		return nil
	case userword.FieldReviewIntervalDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReviewIntervalDays(v)
		return nil
	case userword.FieldReviewFailCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReviewFailCount(v)
		return nil
	case userword.FieldQueryCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQueryCount(v)
		return nil
	}
	return fmt.Errorf("unknown UserWord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserWordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userword.FieldReviewLastReviewAt) {
		fields = append(fields, userword.FieldReviewLastReviewAt)
	}
	if m.FieldCleared(userword.FieldReviewNextReviewAt) {
		fields = append(fields, userword.FieldReviewNextReviewAt)
	}
	if m.FieldCleared(userword.FieldNotes) {
		fields = append(fields, userword.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserWordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserWordMutation) ClearField(name string) error {
	switch name {
	case userword.FieldReviewLastReviewAt:
		m.ClearReviewLastReviewAt()
		return nil
	case userword.FieldReviewNextReviewAt:
		m.ClearReviewNextReviewAt()
		return nil
	case userword.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown UserWord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserWordMutation) ResetField(name string) error {
	switch name {
	case userword.FieldUserID:
		m.ResetUserID()
		return nil
	case userword.FieldWord:
		m.ResetWord()
		return nil
	case userword.FieldLanguage:
		m.ResetLanguage()
		return nil
	case userword.FieldMasteryListen:
		m.ResetMasteryListen()
		return nil
	case userword.FieldMasteryRead:
		m.ResetMasteryRead()
		return nil
	case userword.FieldMasterySpell:
		m.ResetMasterySpell()
		return nil
	case userword.FieldMasteryPronounce:
		m.ResetMasteryPronounce()
		return nil
	case userword.FieldMasteryUse:
		m.ResetMasteryUse()
		return nil
	case userword.FieldMasteryOverall:
		m.ResetMasteryOverall()
		return nil
	case userword.FieldReviewLastReviewAt:
		m.ResetReviewLastReviewAt()
		return nil
	case userword.FieldReviewNextReviewAt:
		m.ResetReviewNextReviewAt()
		return nil
	case userword.FieldReviewIntervalDays:
		m.ResetReviewIntervalDays()
		return nil
	case userword.FieldReviewFailCount:
		m.ResetReviewFailCount()
		return nil
	case userword.FieldQueryCount:
		m.ResetQueryCount()
		return nil
	case userword.FieldNotes:
		m.ResetNotes()
		return nil
	case userword.FieldSentences:
		m.ResetSentences()
		return nil
	case userword.FieldRelations:
		m.ResetRelations()
		return nil
	case userword.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case userword.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userword.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserWord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserWordMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserWordMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserWordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserWordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserWordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserWordMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserWordMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UserWord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserWordMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UserWord edge %s", name)
}

// WordMutation represents an operation that mutates the Word nodes in the graph.
type WordMutation struct {
	config
	op              Op
	typ             string
	id              *int
	text            *string
	language        *string
	word_type       *string
	lemma           *string
	phonetics       *types.WordPhonetics
	appendphonetics types.WordPhonetics
	meanings        *types.WordMeanings
	appendmeanings  types.WordMeanings
	tags            *[]string
	appendtags      []string
	phrases         *types.Phrases
	appendphrases   types.Phrases
	sentences       *types.Sentences
	appendsentences types.Sentences
	relations       *types.WordRelations
	appendrelations types.WordRelations
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Word, error)
	predicates      []predicate.Word
}

var _ ent.Mutation = (*WordMutation)(nil)

// wordOption allows management of the mutation configuration using functional options.
type wordOption func(*WordMutation)

// newWordMutation creates new mutation for the Word entity.
func newWordMutation(c config, op Op, opts ...wordOption) *WordMutation {
	m := &WordMutation{
		config:        c,
		op:            op,
		typ:           TypeWord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWordID sets the ID field of the mutation.
func withWordID(id int) wordOption {
	return func(m *WordMutation) {
		var (
			err   error
			once  sync.Once
			value *Word
		)
		m.oldValue = func(ctx context.Context) (*Word, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Word.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWord sets the old Word of the mutation.
func withWord(node *Word) wordOption {
	return func(m *WordMutation) {
		m.oldValue = func(context.Context) (*Word, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WordMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Word.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetText sets the "text" field.
func (m *WordMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *WordMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *WordMutation) ResetText() {
	m.text = nil
}

// SetLanguage sets the "language" field.
func (m *WordMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *WordMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage resets all changes to the "language" field.
func (m *WordMutation) ResetLanguage() {
	m.language = nil
}

// SetWordType sets the "word_type" field.
func (m *WordMutation) SetWordType(s string) {
	m.word_type = &s
}

// WordType returns the value of the "word_type" field in the mutation.
func (m *WordMutation) WordType() (r string, exists bool) {
	v := m.word_type
	if v == nil {
		return
	}
	return *v, true
}

// OldWordType returns the old "word_type" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldWordType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWordType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWordType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWordType: %w", err)
	}
	return oldValue.WordType, nil
}

// ResetWordType resets all changes to the "word_type" field.
func (m *WordMutation) ResetWordType() {
	m.word_type = nil
}

// SetLemma sets the "lemma" field.
func (m *WordMutation) SetLemma(s string) {
	m.lemma = &s
}

// Lemma returns the value of the "lemma" field in the mutation.
func (m *WordMutation) Lemma() (r string, exists bool) {
	v := m.lemma
	if v == nil {
		return
	}
	return *v, true
}

// OldLemma returns the old "lemma" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldLemma(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLemma is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLemma requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLemma: %w", err)
	}
	return oldValue.Lemma, nil
}

// ClearLemma clears the value of the "lemma" field.
func (m *WordMutation) ClearLemma() {
	m.lemma = nil
	m.clearedFields[word.FieldLemma] = struct{}{}
}

// LemmaCleared returns if the "lemma" field was cleared in this mutation.
func (m *WordMutation) LemmaCleared() bool {
	_, ok := m.clearedFields[word.FieldLemma]
	return ok
}

// ResetLemma resets all changes to the "lemma" field.
func (m *WordMutation) ResetLemma() {
	m.lemma = nil
	delete(m.clearedFields, word.FieldLemma)
}

// SetPhonetics sets the "phonetics" field.
func (m *WordMutation) SetPhonetics(tp types.WordPhonetics) {
	m.phonetics = &tp
	m.appendphonetics = nil
}

// Phonetics returns the value of the "phonetics" field in the mutation.
func (m *WordMutation) Phonetics() (r types.WordPhonetics, exists bool) {
	v := m.phonetics
	if v == nil {
		return
	}
	return *v, true
}

// OldPhonetics returns the old "phonetics" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldPhonetics(ctx context.Context) (v types.WordPhonetics, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhonetics is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhonetics requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhonetics: %w", err)
	}
	return oldValue.Phonetics, nil
}

// AppendPhonetics adds tp to the "phonetics" field.
func (m *WordMutation) AppendPhonetics(tp types.WordPhonetics) {
	m.appendphonetics = append(m.appendphonetics, tp...)
}

// AppendedPhonetics returns the list of values that were appended to the "phonetics" field in this mutation.
func (m *WordMutation) AppendedPhonetics() (types.WordPhonetics, bool) {
	if len(m.appendphonetics) == 0 {
		return nil, false
	}
	return m.appendphonetics, true
}

// ResetPhonetics resets all changes to the "phonetics" field.
func (m *WordMutation) ResetPhonetics() {
	m.phonetics = nil
	m.appendphonetics = nil
}

// SetMeanings sets the "meanings" field.
func (m *WordMutation) SetMeanings(tm types.WordMeanings) {
	m.meanings = &tm
	m.appendmeanings = nil
}

// Meanings returns the value of the "meanings" field in the mutation.
func (m *WordMutation) Meanings() (r types.WordMeanings, exists bool) {
	v := m.meanings
	if v == nil {
		return
	}
	return *v, true
}

// OldMeanings returns the old "meanings" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldMeanings(ctx context.Context) (v types.WordMeanings, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeanings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeanings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeanings: %w", err)
	}
	return oldValue.Meanings, nil
}

// AppendMeanings adds tm to the "meanings" field.
func (m *WordMutation) AppendMeanings(tm types.WordMeanings) {
	m.appendmeanings = append(m.appendmeanings, tm...)
}

// AppendedMeanings returns the list of values that were appended to the "meanings" field in this mutation.
func (m *WordMutation) AppendedMeanings() (types.WordMeanings, bool) {
	if len(m.appendmeanings) == 0 {
		return nil, false
	}
	return m.appendmeanings, true
}

// ResetMeanings resets all changes to the "meanings" field.
func (m *WordMutation) ResetMeanings() {
	m.meanings = nil
	m.appendmeanings = nil
}

// SetTags sets the "tags" field.
func (m *WordMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *WordMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *WordMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *WordMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ResetTags resets all changes to the "tags" field.
func (m *WordMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
}

// SetPhrases sets the "phrases" field.
func (m *WordMutation) SetPhrases(t types.Phrases) {
	m.phrases = &t
	m.appendphrases = nil
}

// Phrases returns the value of the "phrases" field in the mutation.
func (m *WordMutation) Phrases() (r types.Phrases, exists bool) {
	v := m.phrases
	if v == nil {
		return
	}
	return *v, true
}

// OldPhrases returns the old "phrases" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldPhrases(ctx context.Context) (v types.Phrases, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhrases is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhrases requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhrases: %w", err)
	}
	return oldValue.Phrases, nil
}

// AppendPhrases adds t to the "phrases" field.
func (m *WordMutation) AppendPhrases(t types.Phrases) {
	m.appendphrases = append(m.appendphrases, t...)
}

// AppendedPhrases returns the list of values that were appended to the "phrases" field in this mutation.
func (m *WordMutation) AppendedPhrases() (types.Phrases, bool) {
	if len(m.appendphrases) == 0 {
		return nil, false
	}
	return m.appendphrases, true
}

// ResetPhrases resets all changes to the "phrases" field.
func (m *WordMutation) ResetPhrases() {
	m.phrases = nil
	m.appendphrases = nil
}

// SetSentences sets the "sentences" field.
func (m *WordMutation) SetSentences(t types.Sentences) {
	m.sentences = &t
	m.appendsentences = nil
}

// Sentences returns the value of the "sentences" field in the mutation.
func (m *WordMutation) Sentences() (r types.Sentences, exists bool) {
	v := m.sentences
	if v == nil {
		return
	}
	return *v, true
}

// OldSentences returns the old "sentences" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldSentences(ctx context.Context) (v types.Sentences, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentences is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentences requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentences: %w", err)
	}
	return oldValue.Sentences, nil
}

// AppendSentences adds t to the "sentences" field.
func (m *WordMutation) AppendSentences(t types.Sentences) {
	m.appendsentences = append(m.appendsentences, t...)
}

// AppendedSentences returns the list of values that were appended to the "sentences" field in this mutation.
func (m *WordMutation) AppendedSentences() (types.Sentences, bool) {
	if len(m.appendsentences) == 0 {
		return nil, false
	}
	return m.appendsentences, true
}

// ResetSentences resets all changes to the "sentences" field.
func (m *WordMutation) ResetSentences() {
	m.sentences = nil
	m.appendsentences = nil
}

// SetRelations sets the "relations" field.
func (m *WordMutation) SetRelations(tr types.WordRelations) {
	m.relations = &tr
	m.appendrelations = nil
}

// Relations returns the value of the "relations" field in the mutation.
func (m *WordMutation) Relations() (r types.WordRelations, exists bool) {
	v := m.relations
	if v == nil {
		return
	}
	return *v, true
}

// OldRelations returns the old "relations" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldRelations(ctx context.Context) (v types.WordRelations, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelations: %w", err)
	}
	return oldValue.Relations, nil
}

// AppendRelations adds tr to the "relations" field.
func (m *WordMutation) AppendRelations(tr types.WordRelations) {
	m.appendrelations = append(m.appendrelations, tr...)
}

// AppendedRelations returns the list of values that were appended to the "relations" field in this mutation.
func (m *WordMutation) AppendedRelations() (types.WordRelations, bool) {
	if len(m.appendrelations) == 0 {
		return nil, false
	}
	return m.appendrelations, true
}

// ResetRelations resets all changes to the "relations" field.
func (m *WordMutation) ResetRelations() {
	m.relations = nil
	m.appendrelations = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WordMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the WordMutation builder.
func (m *WordMutation) Where(ps ...predicate.Word) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Word, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Word).
func (m *WordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WordMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.text != nil {
		fields = append(fields, word.FieldText)
	}
	if m.language != nil {
		fields = append(fields, word.FieldLanguage)
	}
	if m.word_type != nil {
		fields = append(fields, word.FieldWordType)
	}
	if m.lemma != nil {
		fields = append(fields, word.FieldLemma)
	}
	if m.phonetics != nil {
		fields = append(fields, word.FieldPhonetics)
	}
	if m.meanings != nil {
		fields = append(fields, word.FieldMeanings)
	}
	if m.tags != nil {
		fields = append(fields, word.FieldTags)
	}
	if m.phrases != nil {
		fields = append(fields, word.FieldPhrases)
	}
	if m.sentences != nil {
		fields = append(fields, word.FieldSentences)
	}
	if m.relations != nil {
		fields = append(fields, word.FieldRelations)
	}
	if m.created_at != nil {
		fields = append(fields, word.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, word.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case word.FieldText:
		return m.Text()
	case word.FieldLanguage:
		return m.Language()
	case word.FieldWordType:
		return m.WordType()
	case word.FieldLemma:
		return m.Lemma()
	case word.FieldPhonetics:
		return m.Phonetics()
	case word.FieldMeanings:
		return m.Meanings()
	case word.FieldTags:
		return m.Tags()
	case word.FieldPhrases:
		return m.Phrases()
	case word.FieldSentences:
		return m.Sentences()
	case word.FieldRelations:
		return m.Relations()
	case word.FieldCreatedAt:
		return m.CreatedAt()
	case word.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case word.FieldText:
		return m.OldText(ctx)
	case word.FieldLanguage:
		return m.OldLanguage(ctx)
	case word.FieldWordType:
		return m.OldWordType(ctx)
	case word.FieldLemma:
		return m.OldLemma(ctx)
	case word.FieldPhonetics:
		return m.OldPhonetics(ctx)
	case word.FieldMeanings:
		return m.OldMeanings(ctx)
	case word.FieldTags:
		return m.OldTags(ctx)
	case word.FieldPhrases:
		return m.OldPhrases(ctx)
	case word.FieldSentences:
		return m.OldSentences(ctx)
	case word.FieldRelations:
		return m.OldRelations(ctx)
	case word.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case word.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Word field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case word.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case word.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case word.FieldWordType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWordType(v)
		return nil
	case word.FieldLemma:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLemma(v)
		return nil
	case word.FieldPhonetics:
		v, ok := value.(types.WordPhonetics)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhonetics(v)
		return nil
	case word.FieldMeanings:
		v, ok := value.(types.WordMeanings)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeanings(v)
		return nil
	case word.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case word.FieldPhrases:
		v, ok := value.(types.Phrases)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhrases(v)
		return nil
	case word.FieldSentences:
		v, ok := value.(types.Sentences)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentences(v)
		return nil
	case word.FieldRelations:
		v, ok := value.(types.WordRelations)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelations(v)
		return nil
	case word.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case word.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Word field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Word numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(word.FieldLemma) {
		fields = append(fields, word.FieldLemma)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WordMutation) ClearField(name string) error {
	switch name {
	case word.FieldLemma:
		m.ClearLemma()
		return nil
	}
	return fmt.Errorf("unknown Word nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WordMutation) ResetField(name string) error {
	switch name {
	case word.FieldText:
		m.ResetText()
		return nil
	case word.FieldLanguage:
		m.ResetLanguage()
		return nil
	case word.FieldWordType:
		m.ResetWordType()
		return nil
	case word.FieldLemma:
		m.ResetLemma()
		return nil
	case word.FieldPhonetics:
		m.ResetPhonetics()
		return nil
	case word.FieldMeanings:
		m.ResetMeanings()
		return nil
	case word.FieldTags:
		m.ResetTags()
		return nil
	case word.FieldPhrases:
		m.ResetPhrases()
		return nil
	case word.FieldSentences:
		m.ResetSentences()
		return nil
	case word.FieldRelations:
		m.ResetRelations()
		return nil
	case word.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case word.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Word field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WordMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WordMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WordMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WordMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Word unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WordMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Word edge %s", name)
}
