// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/eslsoft/vocnet/internal/entity"
	"github.com/eslsoft/vocnet/internal/infrastructure/database/ent/learnedword"
	"github.com/eslsoft/vocnet/internal/infrastructure/database/ent/predicate"
	"github.com/eslsoft/vocnet/internal/infrastructure/database/ent/word"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeLearnedWord = "LearnedWord"
	TypeWord        = "Word"
)

// LearnedWordMutation represents an operation that mutates the LearnedWord nodes in the graph.
type LearnedWordMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	user_id                 *int64
	adduser_id              *int64
	term                    *string
	normalized              *string
	language                *string
	mastery_listen          *int16
	addmastery_listen       *int16
	mastery_read            *int16
	addmastery_read         *int16
	mastery_spell           *int16
	addmastery_spell        *int16
	mastery_pronounce       *int16
	addmastery_pronounce    *int16
	mastery_overall         *int32
	addmastery_overall      *int32
	review_last_review_at   *time.Time
	review_next_review_at   *time.Time
	review_interval_days    *int32
	addreview_interval_days *int32
	review_fail_count       *int32
	addreview_fail_count    *int32
	query_count             *int64
	addquery_count          *int64
	notes                   *string
	sentences               *[]entity.Sentence
	appendsentences         []entity.Sentence
	relations               *[]entity.LearnedWordRelation
	appendrelations         []entity.LearnedWordRelation
	tags                    *[]string
	appendtags              []string
	created_by              *string
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	word                    *int
	clearedword             bool
	done                    bool
	oldValue                func(context.Context) (*LearnedWord, error)
	predicates              []predicate.LearnedWord
}

var _ ent.Mutation = (*LearnedWordMutation)(nil)

// learnedwordOption allows management of the mutation configuration using functional options.
type learnedwordOption func(*LearnedWordMutation)

// newLearnedWordMutation creates new mutation for the LearnedWord entity.
func newLearnedWordMutation(c config, op Op, opts ...learnedwordOption) *LearnedWordMutation {
	m := &LearnedWordMutation{
		config:        c,
		op:            op,
		typ:           TypeLearnedWord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLearnedWordID sets the ID field of the mutation.
func withLearnedWordID(id int) learnedwordOption {
	return func(m *LearnedWordMutation) {
		var (
			err   error
			once  sync.Once
			value *LearnedWord
		)
		m.oldValue = func(ctx context.Context) (*LearnedWord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LearnedWord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLearnedWord sets the old LearnedWord of the mutation.
func withLearnedWord(node *LearnedWord) learnedwordOption {
	return func(m *LearnedWordMutation) {
		m.oldValue = func(context.Context) (*LearnedWord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LearnedWordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LearnedWordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LearnedWordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LearnedWordMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LearnedWord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *LearnedWordMutation) SetUserID(i int64) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *LearnedWordMutation) UserID() (r int64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the LearnedWord entity.
// If the LearnedWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LearnedWordMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *LearnedWordMutation) AddUserID(i int64) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *LearnedWordMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *LearnedWordMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetTerm sets the "term" field.
func (m *LearnedWordMutation) SetTerm(s string) {
	m.term = &s
}

// Term returns the value of the "term" field in the mutation.
func (m *LearnedWordMutation) Term() (r string, exists bool) {
	v := m.term
	if v == nil {
		return
	}
	return *v, true
}

// OldTerm returns the old "term" field's value of the LearnedWord entity.
// If the LearnedWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LearnedWordMutation) OldTerm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTerm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTerm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTerm: %w", err)
	}
	return oldValue.Term, nil
}

// ResetTerm resets all changes to the "term" field.
func (m *LearnedWordMutation) ResetTerm() {
	m.term = nil
}

// SetNormalized sets the "normalized" field.
func (m *LearnedWordMutation) SetNormalized(s string) {
	m.normalized = &s
}

// Normalized returns the value of the "normalized" field in the mutation.
func (m *LearnedWordMutation) Normalized() (r string, exists bool) {
	v := m.normalized
	if v == nil {
		return
	}
	return *v, true
}

// OldNormalized returns the old "normalized" field's value of the LearnedWord entity.
// If the LearnedWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LearnedWordMutation) OldNormalized(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNormalized is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNormalized requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNormalized: %w", err)
	}
	return oldValue.Normalized, nil
}

// ResetNormalized resets all changes to the "normalized" field.
func (m *LearnedWordMutation) ResetNormalized() {
	m.normalized = nil
}

// SetLanguage sets the "language" field.
func (m *LearnedWordMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *LearnedWordMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the LearnedWord entity.
// If the LearnedWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LearnedWordMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage resets all changes to the "language" field.
func (m *LearnedWordMutation) ResetLanguage() {
	m.language = nil
}

// SetWordID sets the "word_id" field.
func (m *LearnedWordMutation) SetWordID(i int) {
	m.word = &i
}

// WordID returns the value of the "word_id" field in the mutation.
func (m *LearnedWordMutation) WordID() (r int, exists bool) {
	v := m.word
	if v == nil {
		return
	}
	return *v, true
}

// OldWordID returns the old "word_id" field's value of the LearnedWord entity.
// If the LearnedWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LearnedWordMutation) OldWordID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWordID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWordID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWordID: %w", err)
	}
	return oldValue.WordID, nil
}

// ClearWordID clears the value of the "word_id" field.
func (m *LearnedWordMutation) ClearWordID() {
	m.word = nil
	m.clearedFields[learnedword.FieldWordID] = struct{}{}
}

// WordIDCleared returns if the "word_id" field was cleared in this mutation.
func (m *LearnedWordMutation) WordIDCleared() bool {
	_, ok := m.clearedFields[learnedword.FieldWordID]
	return ok
}

// ResetWordID resets all changes to the "word_id" field.
func (m *LearnedWordMutation) ResetWordID() {
	m.word = nil
	delete(m.clearedFields, learnedword.FieldWordID)
}

// SetMasteryListen sets the "mastery_listen" field.
func (m *LearnedWordMutation) SetMasteryListen(i int16) {
	m.mastery_listen = &i
	m.addmastery_listen = nil
}

// MasteryListen returns the value of the "mastery_listen" field in the mutation.
func (m *LearnedWordMutation) MasteryListen() (r int16, exists bool) {
	v := m.mastery_listen
	if v == nil {
		return
	}
	return *v, true
}

// OldMasteryListen returns the old "mastery_listen" field's value of the LearnedWord entity.
// If the LearnedWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LearnedWordMutation) OldMasteryListen(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMasteryListen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMasteryListen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMasteryListen: %w", err)
	}
	return oldValue.MasteryListen, nil
}

// AddMasteryListen adds i to the "mastery_listen" field.
func (m *LearnedWordMutation) AddMasteryListen(i int16) {
	if m.addmastery_listen != nil {
		*m.addmastery_listen += i
	} else {
		m.addmastery_listen = &i
	}
}

// AddedMasteryListen returns the value that was added to the "mastery_listen" field in this mutation.
func (m *LearnedWordMutation) AddedMasteryListen() (r int16, exists bool) {
	v := m.addmastery_listen
	if v == nil {
		return
	}
	return *v, true
}

// ResetMasteryListen resets all changes to the "mastery_listen" field.
func (m *LearnedWordMutation) ResetMasteryListen() {
	m.mastery_listen = nil
	m.addmastery_listen = nil
}

// SetMasteryRead sets the "mastery_read" field.
func (m *LearnedWordMutation) SetMasteryRead(i int16) {
	m.mastery_read = &i
	m.addmastery_read = nil
}

// MasteryRead returns the value of the "mastery_read" field in the mutation.
func (m *LearnedWordMutation) MasteryRead() (r int16, exists bool) {
	v := m.mastery_read
	if v == nil {
		return
	}
	return *v, true
}

// OldMasteryRead returns the old "mastery_read" field's value of the LearnedWord entity.
// If the LearnedWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LearnedWordMutation) OldMasteryRead(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMasteryRead is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMasteryRead requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMasteryRead: %w", err)
	}
	return oldValue.MasteryRead, nil
}

// AddMasteryRead adds i to the "mastery_read" field.
func (m *LearnedWordMutation) AddMasteryRead(i int16) {
	if m.addmastery_read != nil {
		*m.addmastery_read += i
	} else {
		m.addmastery_read = &i
	}
}

// AddedMasteryRead returns the value that was added to the "mastery_read" field in this mutation.
func (m *LearnedWordMutation) AddedMasteryRead() (r int16, exists bool) {
	v := m.addmastery_read
	if v == nil {
		return
	}
	return *v, true
}

// ResetMasteryRead resets all changes to the "mastery_read" field.
func (m *LearnedWordMutation) ResetMasteryRead() {
	m.mastery_read = nil
	m.addmastery_read = nil
}

// SetMasterySpell sets the "mastery_spell" field.
func (m *LearnedWordMutation) SetMasterySpell(i int16) {
	m.mastery_spell = &i
	m.addmastery_spell = nil
}

// MasterySpell returns the value of the "mastery_spell" field in the mutation.
func (m *LearnedWordMutation) MasterySpell() (r int16, exists bool) {
	v := m.mastery_spell
	if v == nil {
		return
	}
	return *v, true
}

// OldMasterySpell returns the old "mastery_spell" field's value of the LearnedWord entity.
// If the LearnedWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LearnedWordMutation) OldMasterySpell(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMasterySpell is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMasterySpell requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMasterySpell: %w", err)
	}
	return oldValue.MasterySpell, nil
}

// AddMasterySpell adds i to the "mastery_spell" field.
func (m *LearnedWordMutation) AddMasterySpell(i int16) {
	if m.addmastery_spell != nil {
		*m.addmastery_spell += i
	} else {
		m.addmastery_spell = &i
	}
}

// AddedMasterySpell returns the value that was added to the "mastery_spell" field in this mutation.
func (m *LearnedWordMutation) AddedMasterySpell() (r int16, exists bool) {
	v := m.addmastery_spell
	if v == nil {
		return
	}
	return *v, true
}

// ResetMasterySpell resets all changes to the "mastery_spell" field.
func (m *LearnedWordMutation) ResetMasterySpell() {
	m.mastery_spell = nil
	m.addmastery_spell = nil
}

// SetMasteryPronounce sets the "mastery_pronounce" field.
func (m *LearnedWordMutation) SetMasteryPronounce(i int16) {
	m.mastery_pronounce = &i
	m.addmastery_pronounce = nil
}

// MasteryPronounce returns the value of the "mastery_pronounce" field in the mutation.
func (m *LearnedWordMutation) MasteryPronounce() (r int16, exists bool) {
	v := m.mastery_pronounce
	if v == nil {
		return
	}
	return *v, true
}

// OldMasteryPronounce returns the old "mastery_pronounce" field's value of the LearnedWord entity.
// If the LearnedWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LearnedWordMutation) OldMasteryPronounce(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMasteryPronounce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMasteryPronounce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMasteryPronounce: %w", err)
	}
	return oldValue.MasteryPronounce, nil
}

// AddMasteryPronounce adds i to the "mastery_pronounce" field.
func (m *LearnedWordMutation) AddMasteryPronounce(i int16) {
	if m.addmastery_pronounce != nil {
		*m.addmastery_pronounce += i
	} else {
		m.addmastery_pronounce = &i
	}
}

// AddedMasteryPronounce returns the value that was added to the "mastery_pronounce" field in this mutation.
func (m *LearnedWordMutation) AddedMasteryPronounce() (r int16, exists bool) {
	v := m.addmastery_pronounce
	if v == nil {
		return
	}
	return *v, true
}

// ResetMasteryPronounce resets all changes to the "mastery_pronounce" field.
func (m *LearnedWordMutation) ResetMasteryPronounce() {
	m.mastery_pronounce = nil
	m.addmastery_pronounce = nil
}

// SetMasteryOverall sets the "mastery_overall" field.
func (m *LearnedWordMutation) SetMasteryOverall(i int32) {
	m.mastery_overall = &i
	m.addmastery_overall = nil
}

// MasteryOverall returns the value of the "mastery_overall" field in the mutation.
func (m *LearnedWordMutation) MasteryOverall() (r int32, exists bool) {
	v := m.mastery_overall
	if v == nil {
		return
	}
	return *v, true
}

// OldMasteryOverall returns the old "mastery_overall" field's value of the LearnedWord entity.
// If the LearnedWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LearnedWordMutation) OldMasteryOverall(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMasteryOverall is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMasteryOverall requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMasteryOverall: %w", err)
	}
	return oldValue.MasteryOverall, nil
}

// AddMasteryOverall adds i to the "mastery_overall" field.
func (m *LearnedWordMutation) AddMasteryOverall(i int32) {
	if m.addmastery_overall != nil {
		*m.addmastery_overall += i
	} else {
		m.addmastery_overall = &i
	}
}

// AddedMasteryOverall returns the value that was added to the "mastery_overall" field in this mutation.
func (m *LearnedWordMutation) AddedMasteryOverall() (r int32, exists bool) {
	v := m.addmastery_overall
	if v == nil {
		return
	}
	return *v, true
}

// ResetMasteryOverall resets all changes to the "mastery_overall" field.
func (m *LearnedWordMutation) ResetMasteryOverall() {
	m.mastery_overall = nil
	m.addmastery_overall = nil
}

// SetReviewLastReviewAt sets the "review_last_review_at" field.
func (m *LearnedWordMutation) SetReviewLastReviewAt(t time.Time) {
	m.review_last_review_at = &t
}

// ReviewLastReviewAt returns the value of the "review_last_review_at" field in the mutation.
func (m *LearnedWordMutation) ReviewLastReviewAt() (r time.Time, exists bool) {
	v := m.review_last_review_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewLastReviewAt returns the old "review_last_review_at" field's value of the LearnedWord entity.
// If the LearnedWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LearnedWordMutation) OldReviewLastReviewAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewLastReviewAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewLastReviewAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewLastReviewAt: %w", err)
	}
	return oldValue.ReviewLastReviewAt, nil
}

// ClearReviewLastReviewAt clears the value of the "review_last_review_at" field.
func (m *LearnedWordMutation) ClearReviewLastReviewAt() {
	m.review_last_review_at = nil
	m.clearedFields[learnedword.FieldReviewLastReviewAt] = struct{}{}
}

// ReviewLastReviewAtCleared returns if the "review_last_review_at" field was cleared in this mutation.
func (m *LearnedWordMutation) ReviewLastReviewAtCleared() bool {
	_, ok := m.clearedFields[learnedword.FieldReviewLastReviewAt]
	return ok
}

// ResetReviewLastReviewAt resets all changes to the "review_last_review_at" field.
func (m *LearnedWordMutation) ResetReviewLastReviewAt() {
	m.review_last_review_at = nil
	delete(m.clearedFields, learnedword.FieldReviewLastReviewAt)
}

// SetReviewNextReviewAt sets the "review_next_review_at" field.
func (m *LearnedWordMutation) SetReviewNextReviewAt(t time.Time) {
	m.review_next_review_at = &t
}

// ReviewNextReviewAt returns the value of the "review_next_review_at" field in the mutation.
func (m *LearnedWordMutation) ReviewNextReviewAt() (r time.Time, exists bool) {
	v := m.review_next_review_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewNextReviewAt returns the old "review_next_review_at" field's value of the LearnedWord entity.
// If the LearnedWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LearnedWordMutation) OldReviewNextReviewAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewNextReviewAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewNextReviewAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewNextReviewAt: %w", err)
	}
	return oldValue.ReviewNextReviewAt, nil
}

// ClearReviewNextReviewAt clears the value of the "review_next_review_at" field.
func (m *LearnedWordMutation) ClearReviewNextReviewAt() {
	m.review_next_review_at = nil
	m.clearedFields[learnedword.FieldReviewNextReviewAt] = struct{}{}
}

// ReviewNextReviewAtCleared returns if the "review_next_review_at" field was cleared in this mutation.
func (m *LearnedWordMutation) ReviewNextReviewAtCleared() bool {
	_, ok := m.clearedFields[learnedword.FieldReviewNextReviewAt]
	return ok
}

// ResetReviewNextReviewAt resets all changes to the "review_next_review_at" field.
func (m *LearnedWordMutation) ResetReviewNextReviewAt() {
	m.review_next_review_at = nil
	delete(m.clearedFields, learnedword.FieldReviewNextReviewAt)
}

// SetReviewIntervalDays sets the "review_interval_days" field.
func (m *LearnedWordMutation) SetReviewIntervalDays(i int32) {
	m.review_interval_days = &i
	m.addreview_interval_days = nil
}

// ReviewIntervalDays returns the value of the "review_interval_days" field in the mutation.
func (m *LearnedWordMutation) ReviewIntervalDays() (r int32, exists bool) {
	v := m.review_interval_days
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewIntervalDays returns the old "review_interval_days" field's value of the LearnedWord entity.
// If the LearnedWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LearnedWordMutation) OldReviewIntervalDays(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewIntervalDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewIntervalDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewIntervalDays: %w", err)
	}
	return oldValue.ReviewIntervalDays, nil
}

// AddReviewIntervalDays adds i to the "review_interval_days" field.
func (m *LearnedWordMutation) AddReviewIntervalDays(i int32) {
	if m.addreview_interval_days != nil {
		*m.addreview_interval_days += i
	} else {
		m.addreview_interval_days = &i
	}
}

// AddedReviewIntervalDays returns the value that was added to the "review_interval_days" field in this mutation.
func (m *LearnedWordMutation) AddedReviewIntervalDays() (r int32, exists bool) {
	v := m.addreview_interval_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetReviewIntervalDays resets all changes to the "review_interval_days" field.
func (m *LearnedWordMutation) ResetReviewIntervalDays() {
	m.review_interval_days = nil
	m.addreview_interval_days = nil
}

// SetReviewFailCount sets the "review_fail_count" field.
func (m *LearnedWordMutation) SetReviewFailCount(i int32) {
	m.review_fail_count = &i
	m.addreview_fail_count = nil
}

// ReviewFailCount returns the value of the "review_fail_count" field in the mutation.
func (m *LearnedWordMutation) ReviewFailCount() (r int32, exists bool) {
	v := m.review_fail_count
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewFailCount returns the old "review_fail_count" field's value of the LearnedWord entity.
// If the LearnedWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LearnedWordMutation) OldReviewFailCount(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewFailCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewFailCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewFailCount: %w", err)
	}
	return oldValue.ReviewFailCount, nil
}

// AddReviewFailCount adds i to the "review_fail_count" field.
func (m *LearnedWordMutation) AddReviewFailCount(i int32) {
	if m.addreview_fail_count != nil {
		*m.addreview_fail_count += i
	} else {
		m.addreview_fail_count = &i
	}
}

// AddedReviewFailCount returns the value that was added to the "review_fail_count" field in this mutation.
func (m *LearnedWordMutation) AddedReviewFailCount() (r int32, exists bool) {
	v := m.addreview_fail_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetReviewFailCount resets all changes to the "review_fail_count" field.
func (m *LearnedWordMutation) ResetReviewFailCount() {
	m.review_fail_count = nil
	m.addreview_fail_count = nil
}

// SetQueryCount sets the "query_count" field.
func (m *LearnedWordMutation) SetQueryCount(i int64) {
	m.query_count = &i
	m.addquery_count = nil
}

// QueryCount returns the value of the "query_count" field in the mutation.
func (m *LearnedWordMutation) QueryCount() (r int64, exists bool) {
	v := m.query_count
	if v == nil {
		return
	}
	return *v, true
}

// OldQueryCount returns the old "query_count" field's value of the LearnedWord entity.
// If the LearnedWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LearnedWordMutation) OldQueryCount(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQueryCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQueryCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQueryCount: %w", err)
	}
	return oldValue.QueryCount, nil
}

// AddQueryCount adds i to the "query_count" field.
func (m *LearnedWordMutation) AddQueryCount(i int64) {
	if m.addquery_count != nil {
		*m.addquery_count += i
	} else {
		m.addquery_count = &i
	}
}

// AddedQueryCount returns the value that was added to the "query_count" field in this mutation.
func (m *LearnedWordMutation) AddedQueryCount() (r int64, exists bool) {
	v := m.addquery_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetQueryCount resets all changes to the "query_count" field.
func (m *LearnedWordMutation) ResetQueryCount() {
	m.query_count = nil
	m.addquery_count = nil
}

// SetNotes sets the "notes" field.
func (m *LearnedWordMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *LearnedWordMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the LearnedWord entity.
// If the LearnedWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LearnedWordMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *LearnedWordMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[learnedword.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *LearnedWordMutation) NotesCleared() bool {
	_, ok := m.clearedFields[learnedword.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *LearnedWordMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, learnedword.FieldNotes)
}

// SetSentences sets the "sentences" field.
func (m *LearnedWordMutation) SetSentences(e []entity.Sentence) {
	m.sentences = &e
	m.appendsentences = nil
}

// Sentences returns the value of the "sentences" field in the mutation.
func (m *LearnedWordMutation) Sentences() (r []entity.Sentence, exists bool) {
	v := m.sentences
	if v == nil {
		return
	}
	return *v, true
}

// OldSentences returns the old "sentences" field's value of the LearnedWord entity.
// If the LearnedWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LearnedWordMutation) OldSentences(ctx context.Context) (v []entity.Sentence, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentences is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentences requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentences: %w", err)
	}
	return oldValue.Sentences, nil
}

// AppendSentences adds e to the "sentences" field.
func (m *LearnedWordMutation) AppendSentences(e []entity.Sentence) {
	m.appendsentences = append(m.appendsentences, e...)
}

// AppendedSentences returns the list of values that were appended to the "sentences" field in this mutation.
func (m *LearnedWordMutation) AppendedSentences() ([]entity.Sentence, bool) {
	if len(m.appendsentences) == 0 {
		return nil, false
	}
	return m.appendsentences, true
}

// ResetSentences resets all changes to the "sentences" field.
func (m *LearnedWordMutation) ResetSentences() {
	m.sentences = nil
	m.appendsentences = nil
}

// SetRelations sets the "relations" field.
func (m *LearnedWordMutation) SetRelations(ewr []entity.LearnedWordRelation) {
	m.relations = &ewr
	m.appendrelations = nil
}

// Relations returns the value of the "relations" field in the mutation.
func (m *LearnedWordMutation) Relations() (r []entity.LearnedWordRelation, exists bool) {
	v := m.relations
	if v == nil {
		return
	}
	return *v, true
}

// OldRelations returns the old "relations" field's value of the LearnedWord entity.
// If the LearnedWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LearnedWordMutation) OldRelations(ctx context.Context) (v []entity.LearnedWordRelation, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelations: %w", err)
	}
	return oldValue.Relations, nil
}

// AppendRelations adds ewr to the "relations" field.
func (m *LearnedWordMutation) AppendRelations(ewr []entity.LearnedWordRelation) {
	m.appendrelations = append(m.appendrelations, ewr...)
}

// AppendedRelations returns the list of values that were appended to the "relations" field in this mutation.
func (m *LearnedWordMutation) AppendedRelations() ([]entity.LearnedWordRelation, bool) {
	if len(m.appendrelations) == 0 {
		return nil, false
	}
	return m.appendrelations, true
}

// ResetRelations resets all changes to the "relations" field.
func (m *LearnedWordMutation) ResetRelations() {
	m.relations = nil
	m.appendrelations = nil
}

// SetTags sets the "tags" field.
func (m *LearnedWordMutation) SetTags(s []string) {
	m.tags = &s
	m.appendtags = nil
}

// Tags returns the value of the "tags" field in the mutation.
func (m *LearnedWordMutation) Tags() (r []string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the LearnedWord entity.
// If the LearnedWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LearnedWordMutation) OldTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// AppendTags adds s to the "tags" field.
func (m *LearnedWordMutation) AppendTags(s []string) {
	m.appendtags = append(m.appendtags, s...)
}

// AppendedTags returns the list of values that were appended to the "tags" field in this mutation.
func (m *LearnedWordMutation) AppendedTags() ([]string, bool) {
	if len(m.appendtags) == 0 {
		return nil, false
	}
	return m.appendtags, true
}

// ResetTags resets all changes to the "tags" field.
func (m *LearnedWordMutation) ResetTags() {
	m.tags = nil
	m.appendtags = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *LearnedWordMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *LearnedWordMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the LearnedWord entity.
// If the LearnedWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LearnedWordMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *LearnedWordMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LearnedWordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LearnedWordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LearnedWord entity.
// If the LearnedWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LearnedWordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LearnedWordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LearnedWordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LearnedWordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LearnedWord entity.
// If the LearnedWord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LearnedWordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LearnedWordMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearWord clears the "word" edge to the Word entity.
func (m *LearnedWordMutation) ClearWord() {
	m.clearedword = true
	m.clearedFields[learnedword.FieldWordID] = struct{}{}
}

// WordCleared reports if the "word" edge to the Word entity was cleared.
func (m *LearnedWordMutation) WordCleared() bool {
	return m.WordIDCleared() || m.clearedword
}

// WordIDs returns the "word" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WordID instead. It exists only for internal usage by the builders.
func (m *LearnedWordMutation) WordIDs() (ids []int) {
	if id := m.word; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWord resets all changes to the "word" edge.
func (m *LearnedWordMutation) ResetWord() {
	m.word = nil
	m.clearedword = false
}

// Where appends a list predicates to the LearnedWordMutation builder.
func (m *LearnedWordMutation) Where(ps ...predicate.LearnedWord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LearnedWordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LearnedWordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LearnedWord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LearnedWordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LearnedWordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LearnedWord).
func (m *LearnedWordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LearnedWordMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.user_id != nil {
		fields = append(fields, learnedword.FieldUserID)
	}
	if m.term != nil {
		fields = append(fields, learnedword.FieldTerm)
	}
	if m.normalized != nil {
		fields = append(fields, learnedword.FieldNormalized)
	}
	if m.language != nil {
		fields = append(fields, learnedword.FieldLanguage)
	}
	if m.word != nil {
		fields = append(fields, learnedword.FieldWordID)
	}
	if m.mastery_listen != nil {
		fields = append(fields, learnedword.FieldMasteryListen)
	}
	if m.mastery_read != nil {
		fields = append(fields, learnedword.FieldMasteryRead)
	}
	if m.mastery_spell != nil {
		fields = append(fields, learnedword.FieldMasterySpell)
	}
	if m.mastery_pronounce != nil {
		fields = append(fields, learnedword.FieldMasteryPronounce)
	}
	if m.mastery_overall != nil {
		fields = append(fields, learnedword.FieldMasteryOverall)
	}
	if m.review_last_review_at != nil {
		fields = append(fields, learnedword.FieldReviewLastReviewAt)
	}
	if m.review_next_review_at != nil {
		fields = append(fields, learnedword.FieldReviewNextReviewAt)
	}
	if m.review_interval_days != nil {
		fields = append(fields, learnedword.FieldReviewIntervalDays)
	}
	if m.review_fail_count != nil {
		fields = append(fields, learnedword.FieldReviewFailCount)
	}
	if m.query_count != nil {
		fields = append(fields, learnedword.FieldQueryCount)
	}
	if m.notes != nil {
		fields = append(fields, learnedword.FieldNotes)
	}
	if m.sentences != nil {
		fields = append(fields, learnedword.FieldSentences)
	}
	if m.relations != nil {
		fields = append(fields, learnedword.FieldRelations)
	}
	if m.tags != nil {
		fields = append(fields, learnedword.FieldTags)
	}
	if m.created_by != nil {
		fields = append(fields, learnedword.FieldCreatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, learnedword.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, learnedword.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LearnedWordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case learnedword.FieldUserID:
		return m.UserID()
	case learnedword.FieldTerm:
		return m.Term()
	case learnedword.FieldNormalized:
		return m.Normalized()
	case learnedword.FieldLanguage:
		return m.Language()
	case learnedword.FieldWordID:
		return m.WordID()
	case learnedword.FieldMasteryListen:
		return m.MasteryListen()
	case learnedword.FieldMasteryRead:
		return m.MasteryRead()
	case learnedword.FieldMasterySpell:
		return m.MasterySpell()
	case learnedword.FieldMasteryPronounce:
		return m.MasteryPronounce()
	case learnedword.FieldMasteryOverall:
		return m.MasteryOverall()
	case learnedword.FieldReviewLastReviewAt:
		return m.ReviewLastReviewAt()
	case learnedword.FieldReviewNextReviewAt:
		return m.ReviewNextReviewAt()
	case learnedword.FieldReviewIntervalDays:
		return m.ReviewIntervalDays()
	case learnedword.FieldReviewFailCount:
		return m.ReviewFailCount()
	case learnedword.FieldQueryCount:
		return m.QueryCount()
	case learnedword.FieldNotes:
		return m.Notes()
	case learnedword.FieldSentences:
		return m.Sentences()
	case learnedword.FieldRelations:
		return m.Relations()
	case learnedword.FieldTags:
		return m.Tags()
	case learnedword.FieldCreatedBy:
		return m.CreatedBy()
	case learnedword.FieldCreatedAt:
		return m.CreatedAt()
	case learnedword.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LearnedWordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case learnedword.FieldUserID:
		return m.OldUserID(ctx)
	case learnedword.FieldTerm:
		return m.OldTerm(ctx)
	case learnedword.FieldNormalized:
		return m.OldNormalized(ctx)
	case learnedword.FieldLanguage:
		return m.OldLanguage(ctx)
	case learnedword.FieldWordID:
		return m.OldWordID(ctx)
	case learnedword.FieldMasteryListen:
		return m.OldMasteryListen(ctx)
	case learnedword.FieldMasteryRead:
		return m.OldMasteryRead(ctx)
	case learnedword.FieldMasterySpell:
		return m.OldMasterySpell(ctx)
	case learnedword.FieldMasteryPronounce:
		return m.OldMasteryPronounce(ctx)
	case learnedword.FieldMasteryOverall:
		return m.OldMasteryOverall(ctx)
	case learnedword.FieldReviewLastReviewAt:
		return m.OldReviewLastReviewAt(ctx)
	case learnedword.FieldReviewNextReviewAt:
		return m.OldReviewNextReviewAt(ctx)
	case learnedword.FieldReviewIntervalDays:
		return m.OldReviewIntervalDays(ctx)
	case learnedword.FieldReviewFailCount:
		return m.OldReviewFailCount(ctx)
	case learnedword.FieldQueryCount:
		return m.OldQueryCount(ctx)
	case learnedword.FieldNotes:
		return m.OldNotes(ctx)
	case learnedword.FieldSentences:
		return m.OldSentences(ctx)
	case learnedword.FieldRelations:
		return m.OldRelations(ctx)
	case learnedword.FieldTags:
		return m.OldTags(ctx)
	case learnedword.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case learnedword.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case learnedword.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown LearnedWord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LearnedWordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case learnedword.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case learnedword.FieldTerm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTerm(v)
		return nil
	case learnedword.FieldNormalized:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNormalized(v)
		return nil
	case learnedword.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case learnedword.FieldWordID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWordID(v)
		return nil
	case learnedword.FieldMasteryListen:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMasteryListen(v)
		return nil
	case learnedword.FieldMasteryRead:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMasteryRead(v)
		return nil
	case learnedword.FieldMasterySpell:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMasterySpell(v)
		return nil
	case learnedword.FieldMasteryPronounce:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMasteryPronounce(v)
		return nil
	case learnedword.FieldMasteryOverall:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMasteryOverall(v)
		return nil
	case learnedword.FieldReviewLastReviewAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewLastReviewAt(v)
		return nil
	case learnedword.FieldReviewNextReviewAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewNextReviewAt(v)
		return nil
	case learnedword.FieldReviewIntervalDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewIntervalDays(v)
		return nil
	case learnedword.FieldReviewFailCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewFailCount(v)
		return nil
	case learnedword.FieldQueryCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQueryCount(v)
		return nil
	case learnedword.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case learnedword.FieldSentences:
		v, ok := value.([]entity.Sentence)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentences(v)
		return nil
	case learnedword.FieldRelations:
		v, ok := value.([]entity.LearnedWordRelation)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelations(v)
		return nil
	case learnedword.FieldTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case learnedword.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case learnedword.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case learnedword.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown LearnedWord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LearnedWordMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, learnedword.FieldUserID)
	}
	if m.addmastery_listen != nil {
		fields = append(fields, learnedword.FieldMasteryListen)
	}
	if m.addmastery_read != nil {
		fields = append(fields, learnedword.FieldMasteryRead)
	}
	if m.addmastery_spell != nil {
		fields = append(fields, learnedword.FieldMasterySpell)
	}
	if m.addmastery_pronounce != nil {
		fields = append(fields, learnedword.FieldMasteryPronounce)
	}
	if m.addmastery_overall != nil {
		fields = append(fields, learnedword.FieldMasteryOverall)
	}
	if m.addreview_interval_days != nil {
		fields = append(fields, learnedword.FieldReviewIntervalDays)
	}
	if m.addreview_fail_count != nil {
		fields = append(fields, learnedword.FieldReviewFailCount)
	}
	if m.addquery_count != nil {
		fields = append(fields, learnedword.FieldQueryCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LearnedWordMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case learnedword.FieldUserID:
		return m.AddedUserID()
	case learnedword.FieldMasteryListen:
		return m.AddedMasteryListen()
	case learnedword.FieldMasteryRead:
		return m.AddedMasteryRead()
	case learnedword.FieldMasterySpell:
		return m.AddedMasterySpell()
	case learnedword.FieldMasteryPronounce:
		return m.AddedMasteryPronounce()
	case learnedword.FieldMasteryOverall:
		return m.AddedMasteryOverall()
	case learnedword.FieldReviewIntervalDays:
		return m.AddedReviewIntervalDays()
	case learnedword.FieldReviewFailCount:
		return m.AddedReviewFailCount()
	case learnedword.FieldQueryCount:
		return m.AddedQueryCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LearnedWordMutation) AddField(name string, value ent.Value) error {
	switch name {
	case learnedword.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case learnedword.FieldMasteryListen:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMasteryListen(v)
		return nil
	case learnedword.FieldMasteryRead:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMasteryRead(v)
		return nil
	case learnedword.FieldMasterySpell:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMasterySpell(v)
		return nil
	case learnedword.FieldMasteryPronounce:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMasteryPronounce(v)
		return nil
	case learnedword.FieldMasteryOverall:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMasteryOverall(v)
		return nil
	case learnedword.FieldReviewIntervalDays:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReviewIntervalDays(v)
		return nil
	case learnedword.FieldReviewFailCount:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReviewFailCount(v)
		return nil
	case learnedword.FieldQueryCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQueryCount(v)
		return nil
	}
	return fmt.Errorf("unknown LearnedWord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LearnedWordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(learnedword.FieldWordID) {
		fields = append(fields, learnedword.FieldWordID)
	}
	if m.FieldCleared(learnedword.FieldReviewLastReviewAt) {
		fields = append(fields, learnedword.FieldReviewLastReviewAt)
	}
	if m.FieldCleared(learnedword.FieldReviewNextReviewAt) {
		fields = append(fields, learnedword.FieldReviewNextReviewAt)
	}
	if m.FieldCleared(learnedword.FieldNotes) {
		fields = append(fields, learnedword.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LearnedWordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LearnedWordMutation) ClearField(name string) error {
	switch name {
	case learnedword.FieldWordID:
		m.ClearWordID()
		return nil
	case learnedword.FieldReviewLastReviewAt:
		m.ClearReviewLastReviewAt()
		return nil
	case learnedword.FieldReviewNextReviewAt:
		m.ClearReviewNextReviewAt()
		return nil
	case learnedword.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown LearnedWord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LearnedWordMutation) ResetField(name string) error {
	switch name {
	case learnedword.FieldUserID:
		m.ResetUserID()
		return nil
	case learnedword.FieldTerm:
		m.ResetTerm()
		return nil
	case learnedword.FieldNormalized:
		m.ResetNormalized()
		return nil
	case learnedword.FieldLanguage:
		m.ResetLanguage()
		return nil
	case learnedword.FieldWordID:
		m.ResetWordID()
		return nil
	case learnedword.FieldMasteryListen:
		m.ResetMasteryListen()
		return nil
	case learnedword.FieldMasteryRead:
		m.ResetMasteryRead()
		return nil
	case learnedword.FieldMasterySpell:
		m.ResetMasterySpell()
		return nil
	case learnedword.FieldMasteryPronounce:
		m.ResetMasteryPronounce()
		return nil
	case learnedword.FieldMasteryOverall:
		m.ResetMasteryOverall()
		return nil
	case learnedword.FieldReviewLastReviewAt:
		m.ResetReviewLastReviewAt()
		return nil
	case learnedword.FieldReviewNextReviewAt:
		m.ResetReviewNextReviewAt()
		return nil
	case learnedword.FieldReviewIntervalDays:
		m.ResetReviewIntervalDays()
		return nil
	case learnedword.FieldReviewFailCount:
		m.ResetReviewFailCount()
		return nil
	case learnedword.FieldQueryCount:
		m.ResetQueryCount()
		return nil
	case learnedword.FieldNotes:
		m.ResetNotes()
		return nil
	case learnedword.FieldSentences:
		m.ResetSentences()
		return nil
	case learnedword.FieldRelations:
		m.ResetRelations()
		return nil
	case learnedword.FieldTags:
		m.ResetTags()
		return nil
	case learnedword.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case learnedword.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case learnedword.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown LearnedWord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LearnedWordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.word != nil {
		edges = append(edges, learnedword.EdgeWord)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LearnedWordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case learnedword.EdgeWord:
		if id := m.word; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LearnedWordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LearnedWordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LearnedWordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedword {
		edges = append(edges, learnedword.EdgeWord)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LearnedWordMutation) EdgeCleared(name string) bool {
	switch name {
	case learnedword.EdgeWord:
		return m.clearedword
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LearnedWordMutation) ClearEdge(name string) error {
	switch name {
	case learnedword.EdgeWord:
		m.ClearWord()
		return nil
	}
	return fmt.Errorf("unknown LearnedWord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LearnedWordMutation) ResetEdge(name string) error {
	switch name {
	case learnedword.EdgeWord:
		m.ResetWord()
		return nil
	}
	return fmt.Errorf("unknown LearnedWord edge %s", name)
}

// WordMutation represents an operation that mutates the Word nodes in the graph.
type WordMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	text                 *string
	normalized           *string
	language             *string
	word_type            *string
	lemma                *string
	phonetics            *[]entity.WordPhonetic
	appendphonetics      []entity.WordPhonetic
	definitions          *[]entity.WordDefinition
	appenddefinitions    []entity.WordDefinition
	phrases              *[]entity.Phrase
	appendphrases        []entity.Phrase
	sentences            *[]entity.Sentence
	appendsentences      []entity.Sentence
	relations            *[]entity.WordRelation
	appendrelations      []entity.WordRelation
	categories           *[]string
	appendcategories     []string
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	learned_words        map[int]struct{}
	removedlearned_words map[int]struct{}
	clearedlearned_words bool
	done                 bool
	oldValue             func(context.Context) (*Word, error)
	predicates           []predicate.Word
}

var _ ent.Mutation = (*WordMutation)(nil)

// wordOption allows management of the mutation configuration using functional options.
type wordOption func(*WordMutation)

// newWordMutation creates new mutation for the Word entity.
func newWordMutation(c config, op Op, opts ...wordOption) *WordMutation {
	m := &WordMutation{
		config:        c,
		op:            op,
		typ:           TypeWord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWordID sets the ID field of the mutation.
func withWordID(id int) wordOption {
	return func(m *WordMutation) {
		var (
			err   error
			once  sync.Once
			value *Word
		)
		m.oldValue = func(ctx context.Context) (*Word, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Word.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWord sets the old Word of the mutation.
func withWord(node *Word) wordOption {
	return func(m *WordMutation) {
		m.oldValue = func(context.Context) (*Word, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WordMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Word.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetText sets the "text" field.
func (m *WordMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *WordMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *WordMutation) ResetText() {
	m.text = nil
}

// SetNormalized sets the "normalized" field.
func (m *WordMutation) SetNormalized(s string) {
	m.normalized = &s
}

// Normalized returns the value of the "normalized" field in the mutation.
func (m *WordMutation) Normalized() (r string, exists bool) {
	v := m.normalized
	if v == nil {
		return
	}
	return *v, true
}

// OldNormalized returns the old "normalized" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldNormalized(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNormalized is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNormalized requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNormalized: %w", err)
	}
	return oldValue.Normalized, nil
}

// ResetNormalized resets all changes to the "normalized" field.
func (m *WordMutation) ResetNormalized() {
	m.normalized = nil
}

// SetLanguage sets the "language" field.
func (m *WordMutation) SetLanguage(s string) {
	m.language = &s
}

// Language returns the value of the "language" field in the mutation.
func (m *WordMutation) Language() (r string, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage resets all changes to the "language" field.
func (m *WordMutation) ResetLanguage() {
	m.language = nil
}

// SetWordType sets the "word_type" field.
func (m *WordMutation) SetWordType(s string) {
	m.word_type = &s
}

// WordType returns the value of the "word_type" field in the mutation.
func (m *WordMutation) WordType() (r string, exists bool) {
	v := m.word_type
	if v == nil {
		return
	}
	return *v, true
}

// OldWordType returns the old "word_type" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldWordType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWordType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWordType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWordType: %w", err)
	}
	return oldValue.WordType, nil
}

// ResetWordType resets all changes to the "word_type" field.
func (m *WordMutation) ResetWordType() {
	m.word_type = nil
}

// SetLemma sets the "lemma" field.
func (m *WordMutation) SetLemma(s string) {
	m.lemma = &s
}

// Lemma returns the value of the "lemma" field in the mutation.
func (m *WordMutation) Lemma() (r string, exists bool) {
	v := m.lemma
	if v == nil {
		return
	}
	return *v, true
}

// OldLemma returns the old "lemma" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldLemma(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLemma is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLemma requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLemma: %w", err)
	}
	return oldValue.Lemma, nil
}

// ClearLemma clears the value of the "lemma" field.
func (m *WordMutation) ClearLemma() {
	m.lemma = nil
	m.clearedFields[word.FieldLemma] = struct{}{}
}

// LemmaCleared returns if the "lemma" field was cleared in this mutation.
func (m *WordMutation) LemmaCleared() bool {
	_, ok := m.clearedFields[word.FieldLemma]
	return ok
}

// ResetLemma resets all changes to the "lemma" field.
func (m *WordMutation) ResetLemma() {
	m.lemma = nil
	delete(m.clearedFields, word.FieldLemma)
}

// SetPhonetics sets the "phonetics" field.
func (m *WordMutation) SetPhonetics(ep []entity.WordPhonetic) {
	m.phonetics = &ep
	m.appendphonetics = nil
}

// Phonetics returns the value of the "phonetics" field in the mutation.
func (m *WordMutation) Phonetics() (r []entity.WordPhonetic, exists bool) {
	v := m.phonetics
	if v == nil {
		return
	}
	return *v, true
}

// OldPhonetics returns the old "phonetics" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldPhonetics(ctx context.Context) (v []entity.WordPhonetic, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhonetics is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhonetics requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhonetics: %w", err)
	}
	return oldValue.Phonetics, nil
}

// AppendPhonetics adds ep to the "phonetics" field.
func (m *WordMutation) AppendPhonetics(ep []entity.WordPhonetic) {
	m.appendphonetics = append(m.appendphonetics, ep...)
}

// AppendedPhonetics returns the list of values that were appended to the "phonetics" field in this mutation.
func (m *WordMutation) AppendedPhonetics() ([]entity.WordPhonetic, bool) {
	if len(m.appendphonetics) == 0 {
		return nil, false
	}
	return m.appendphonetics, true
}

// ResetPhonetics resets all changes to the "phonetics" field.
func (m *WordMutation) ResetPhonetics() {
	m.phonetics = nil
	m.appendphonetics = nil
}

// SetDefinitions sets the "definitions" field.
func (m *WordMutation) SetDefinitions(ed []entity.WordDefinition) {
	m.definitions = &ed
	m.appenddefinitions = nil
}

// Definitions returns the value of the "definitions" field in the mutation.
func (m *WordMutation) Definitions() (r []entity.WordDefinition, exists bool) {
	v := m.definitions
	if v == nil {
		return
	}
	return *v, true
}

// OldDefinitions returns the old "definitions" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldDefinitions(ctx context.Context) (v []entity.WordDefinition, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefinitions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefinitions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefinitions: %w", err)
	}
	return oldValue.Definitions, nil
}

// AppendDefinitions adds ed to the "definitions" field.
func (m *WordMutation) AppendDefinitions(ed []entity.WordDefinition) {
	m.appenddefinitions = append(m.appenddefinitions, ed...)
}

// AppendedDefinitions returns the list of values that were appended to the "definitions" field in this mutation.
func (m *WordMutation) AppendedDefinitions() ([]entity.WordDefinition, bool) {
	if len(m.appenddefinitions) == 0 {
		return nil, false
	}
	return m.appenddefinitions, true
}

// ResetDefinitions resets all changes to the "definitions" field.
func (m *WordMutation) ResetDefinitions() {
	m.definitions = nil
	m.appenddefinitions = nil
}

// SetPhrases sets the "phrases" field.
func (m *WordMutation) SetPhrases(e []entity.Phrase) {
	m.phrases = &e
	m.appendphrases = nil
}

// Phrases returns the value of the "phrases" field in the mutation.
func (m *WordMutation) Phrases() (r []entity.Phrase, exists bool) {
	v := m.phrases
	if v == nil {
		return
	}
	return *v, true
}

// OldPhrases returns the old "phrases" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldPhrases(ctx context.Context) (v []entity.Phrase, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhrases is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhrases requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhrases: %w", err)
	}
	return oldValue.Phrases, nil
}

// AppendPhrases adds e to the "phrases" field.
func (m *WordMutation) AppendPhrases(e []entity.Phrase) {
	m.appendphrases = append(m.appendphrases, e...)
}

// AppendedPhrases returns the list of values that were appended to the "phrases" field in this mutation.
func (m *WordMutation) AppendedPhrases() ([]entity.Phrase, bool) {
	if len(m.appendphrases) == 0 {
		return nil, false
	}
	return m.appendphrases, true
}

// ResetPhrases resets all changes to the "phrases" field.
func (m *WordMutation) ResetPhrases() {
	m.phrases = nil
	m.appendphrases = nil
}

// SetSentences sets the "sentences" field.
func (m *WordMutation) SetSentences(e []entity.Sentence) {
	m.sentences = &e
	m.appendsentences = nil
}

// Sentences returns the value of the "sentences" field in the mutation.
func (m *WordMutation) Sentences() (r []entity.Sentence, exists bool) {
	v := m.sentences
	if v == nil {
		return
	}
	return *v, true
}

// OldSentences returns the old "sentences" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldSentences(ctx context.Context) (v []entity.Sentence, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentences is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentences requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentences: %w", err)
	}
	return oldValue.Sentences, nil
}

// AppendSentences adds e to the "sentences" field.
func (m *WordMutation) AppendSentences(e []entity.Sentence) {
	m.appendsentences = append(m.appendsentences, e...)
}

// AppendedSentences returns the list of values that were appended to the "sentences" field in this mutation.
func (m *WordMutation) AppendedSentences() ([]entity.Sentence, bool) {
	if len(m.appendsentences) == 0 {
		return nil, false
	}
	return m.appendsentences, true
}

// ResetSentences resets all changes to the "sentences" field.
func (m *WordMutation) ResetSentences() {
	m.sentences = nil
	m.appendsentences = nil
}

// SetRelations sets the "relations" field.
func (m *WordMutation) SetRelations(er []entity.WordRelation) {
	m.relations = &er
	m.appendrelations = nil
}

// Relations returns the value of the "relations" field in the mutation.
func (m *WordMutation) Relations() (r []entity.WordRelation, exists bool) {
	v := m.relations
	if v == nil {
		return
	}
	return *v, true
}

// OldRelations returns the old "relations" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldRelations(ctx context.Context) (v []entity.WordRelation, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRelations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRelations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRelations: %w", err)
	}
	return oldValue.Relations, nil
}

// AppendRelations adds er to the "relations" field.
func (m *WordMutation) AppendRelations(er []entity.WordRelation) {
	m.appendrelations = append(m.appendrelations, er...)
}

// AppendedRelations returns the list of values that were appended to the "relations" field in this mutation.
func (m *WordMutation) AppendedRelations() ([]entity.WordRelation, bool) {
	if len(m.appendrelations) == 0 {
		return nil, false
	}
	return m.appendrelations, true
}

// ResetRelations resets all changes to the "relations" field.
func (m *WordMutation) ResetRelations() {
	m.relations = nil
	m.appendrelations = nil
}

// SetCategories sets the "categories" field.
func (m *WordMutation) SetCategories(s []string) {
	m.categories = &s
	m.appendcategories = nil
}

// Categories returns the value of the "categories" field in the mutation.
func (m *WordMutation) Categories() (r []string, exists bool) {
	v := m.categories
	if v == nil {
		return
	}
	return *v, true
}

// OldCategories returns the old "categories" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldCategories(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategories is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategories requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategories: %w", err)
	}
	return oldValue.Categories, nil
}

// AppendCategories adds s to the "categories" field.
func (m *WordMutation) AppendCategories(s []string) {
	m.appendcategories = append(m.appendcategories, s...)
}

// AppendedCategories returns the list of values that were appended to the "categories" field in this mutation.
func (m *WordMutation) AppendedCategories() ([]string, bool) {
	if len(m.appendcategories) == 0 {
		return nil, false
	}
	return m.appendcategories, true
}

// ResetCategories resets all changes to the "categories" field.
func (m *WordMutation) ResetCategories() {
	m.categories = nil
	m.appendcategories = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WordMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WordMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WordMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WordMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WordMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Word entity.
// If the Word object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WordMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WordMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddLearnedWordIDs adds the "learned_words" edge to the LearnedWord entity by ids.
func (m *WordMutation) AddLearnedWordIDs(ids ...int) {
	if m.learned_words == nil {
		m.learned_words = make(map[int]struct{})
	}
	for i := range ids {
		m.learned_words[ids[i]] = struct{}{}
	}
}

// ClearLearnedWords clears the "learned_words" edge to the LearnedWord entity.
func (m *WordMutation) ClearLearnedWords() {
	m.clearedlearned_words = true
}

// LearnedWordsCleared reports if the "learned_words" edge to the LearnedWord entity was cleared.
func (m *WordMutation) LearnedWordsCleared() bool {
	return m.clearedlearned_words
}

// RemoveLearnedWordIDs removes the "learned_words" edge to the LearnedWord entity by IDs.
func (m *WordMutation) RemoveLearnedWordIDs(ids ...int) {
	if m.removedlearned_words == nil {
		m.removedlearned_words = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.learned_words, ids[i])
		m.removedlearned_words[ids[i]] = struct{}{}
	}
}

// RemovedLearnedWords returns the removed IDs of the "learned_words" edge to the LearnedWord entity.
func (m *WordMutation) RemovedLearnedWordsIDs() (ids []int) {
	for id := range m.removedlearned_words {
		ids = append(ids, id)
	}
	return
}

// LearnedWordsIDs returns the "learned_words" edge IDs in the mutation.
func (m *WordMutation) LearnedWordsIDs() (ids []int) {
	for id := range m.learned_words {
		ids = append(ids, id)
	}
	return
}

// ResetLearnedWords resets all changes to the "learned_words" edge.
func (m *WordMutation) ResetLearnedWords() {
	m.learned_words = nil
	m.clearedlearned_words = false
	m.removedlearned_words = nil
}

// Where appends a list predicates to the WordMutation builder.
func (m *WordMutation) Where(ps ...predicate.Word) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Word, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Word).
func (m *WordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WordMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.text != nil {
		fields = append(fields, word.FieldText)
	}
	if m.normalized != nil {
		fields = append(fields, word.FieldNormalized)
	}
	if m.language != nil {
		fields = append(fields, word.FieldLanguage)
	}
	if m.word_type != nil {
		fields = append(fields, word.FieldWordType)
	}
	if m.lemma != nil {
		fields = append(fields, word.FieldLemma)
	}
	if m.phonetics != nil {
		fields = append(fields, word.FieldPhonetics)
	}
	if m.definitions != nil {
		fields = append(fields, word.FieldDefinitions)
	}
	if m.phrases != nil {
		fields = append(fields, word.FieldPhrases)
	}
	if m.sentences != nil {
		fields = append(fields, word.FieldSentences)
	}
	if m.relations != nil {
		fields = append(fields, word.FieldRelations)
	}
	if m.categories != nil {
		fields = append(fields, word.FieldCategories)
	}
	if m.created_at != nil {
		fields = append(fields, word.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, word.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case word.FieldText:
		return m.Text()
	case word.FieldNormalized:
		return m.Normalized()
	case word.FieldLanguage:
		return m.Language()
	case word.FieldWordType:
		return m.WordType()
	case word.FieldLemma:
		return m.Lemma()
	case word.FieldPhonetics:
		return m.Phonetics()
	case word.FieldDefinitions:
		return m.Definitions()
	case word.FieldPhrases:
		return m.Phrases()
	case word.FieldSentences:
		return m.Sentences()
	case word.FieldRelations:
		return m.Relations()
	case word.FieldCategories:
		return m.Categories()
	case word.FieldCreatedAt:
		return m.CreatedAt()
	case word.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case word.FieldText:
		return m.OldText(ctx)
	case word.FieldNormalized:
		return m.OldNormalized(ctx)
	case word.FieldLanguage:
		return m.OldLanguage(ctx)
	case word.FieldWordType:
		return m.OldWordType(ctx)
	case word.FieldLemma:
		return m.OldLemma(ctx)
	case word.FieldPhonetics:
		return m.OldPhonetics(ctx)
	case word.FieldDefinitions:
		return m.OldDefinitions(ctx)
	case word.FieldPhrases:
		return m.OldPhrases(ctx)
	case word.FieldSentences:
		return m.OldSentences(ctx)
	case word.FieldRelations:
		return m.OldRelations(ctx)
	case word.FieldCategories:
		return m.OldCategories(ctx)
	case word.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case word.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Word field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case word.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case word.FieldNormalized:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNormalized(v)
		return nil
	case word.FieldLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case word.FieldWordType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWordType(v)
		return nil
	case word.FieldLemma:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLemma(v)
		return nil
	case word.FieldPhonetics:
		v, ok := value.([]entity.WordPhonetic)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhonetics(v)
		return nil
	case word.FieldDefinitions:
		v, ok := value.([]entity.WordDefinition)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefinitions(v)
		return nil
	case word.FieldPhrases:
		v, ok := value.([]entity.Phrase)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhrases(v)
		return nil
	case word.FieldSentences:
		v, ok := value.([]entity.Sentence)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentences(v)
		return nil
	case word.FieldRelations:
		v, ok := value.([]entity.WordRelation)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRelations(v)
		return nil
	case word.FieldCategories:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategories(v)
		return nil
	case word.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case word.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Word field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Word numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WordMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(word.FieldLemma) {
		fields = append(fields, word.FieldLemma)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WordMutation) ClearField(name string) error {
	switch name {
	case word.FieldLemma:
		m.ClearLemma()
		return nil
	}
	return fmt.Errorf("unknown Word nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WordMutation) ResetField(name string) error {
	switch name {
	case word.FieldText:
		m.ResetText()
		return nil
	case word.FieldNormalized:
		m.ResetNormalized()
		return nil
	case word.FieldLanguage:
		m.ResetLanguage()
		return nil
	case word.FieldWordType:
		m.ResetWordType()
		return nil
	case word.FieldLemma:
		m.ResetLemma()
		return nil
	case word.FieldPhonetics:
		m.ResetPhonetics()
		return nil
	case word.FieldDefinitions:
		m.ResetDefinitions()
		return nil
	case word.FieldPhrases:
		m.ResetPhrases()
		return nil
	case word.FieldSentences:
		m.ResetSentences()
		return nil
	case word.FieldRelations:
		m.ResetRelations()
		return nil
	case word.FieldCategories:
		m.ResetCategories()
		return nil
	case word.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case word.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Word field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.learned_words != nil {
		edges = append(edges, word.EdgeLearnedWords)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case word.EdgeLearnedWords:
		ids := make([]ent.Value, 0, len(m.learned_words))
		for id := range m.learned_words {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedlearned_words != nil {
		edges = append(edges, word.EdgeLearnedWords)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case word.EdgeLearnedWords:
		ids := make([]ent.Value, 0, len(m.removedlearned_words))
		for id := range m.removedlearned_words {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlearned_words {
		edges = append(edges, word.EdgeLearnedWords)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WordMutation) EdgeCleared(name string) bool {
	switch name {
	case word.EdgeLearnedWords:
		return m.clearedlearned_words
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WordMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Word unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WordMutation) ResetEdge(name string) error {
	switch name {
	case word.EdgeLearnedWords:
		m.ResetLearnedWords()
		return nil
	}
	return fmt.Errorf("unknown Word edge %s", name)
}
