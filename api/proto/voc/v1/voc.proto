syntax = "proto3";

package voc.v1;

import "google/protobuf/timestamp.proto";
import "common/v1/enums.proto";
import "common/v1/types.proto";

option go_package = "github.com/eslsoft/vocnet/api/gen/voc/v1;vocv1";

message Voc {
  int64 id = 1;                          // Auto-increment ID (CRUD only)
  string text = 2;                       // Surface form (lemma or inflected/variant form)
  common.v1.Language language = 3;       // Language of the entry
  string voc_type = 4;                   // Allowed values: lemma, past, pp (past participle), ing (present participle / gerund), 3sg (third person singular), plural, comparative, superlative, variant, derived, other
  string lemma = 5;                      // Present only if voc_type != lemma; empty when this is the lemma itself
  string phonetic = 6;                   // IPA or phonetic transcription (optional)
  repeated VocMeaning meanings = 7;      // Only populated on lemma rows
  repeated string tags = 8;              // Difficulty / semantic / topic tags
  google.protobuf.Timestamp created_at = 9;

  // When this entry is a lemma (voc_type == "lemma"), forms lists all other surface forms
  // (e.g. past, past_participle, plural, etc.) referencing this lemma. It MUST NOT include
  // the lemma itself.
  // When this entry is a non-lemma form, forms is empty; the original lemma text can be
  // obtained from the `lemma` field. We return structured objects instead of plain strings
  // so the client knows which type each form is without extra lookups.
  repeated VocFormRef forms = 30;
}

message VocMeaning {
  string pos = 1;                // e.g. n., v., adj.
  string definition = 2;         // English meaning/definition
  string translation = 3;        // Chinese translation / gloss
}

// Minimal reference for an inflected / variant form; no id to keep payload light.
message VocFormRef {
  string text = 1;      // The surface form text
  string voc_type = 2;  // The specific form type (same value domain as Voc.voc_type)
}

// Removed VocForm due to new flattened schema using voc_type + lemma linkage.

// =====================================================================================
// Existing user-related structures below kept conceptually; may be adapted later to new model.
// =====================================================================================

// User's personal word record with learning context
message UserWord {
  int64 id = 1;
  int64 user_id = 2;
  int64 word_id = 3;                                    // Reference to global word (nullable)
  string custom_text = 4;                               // For ad-hoc words not in global table
  common.v1.WordStatus status = 5;                      // Current learning status
  common.v1.MasteryBreakdown mastery = 6;               // Detailed mastery scores
  common.v1.ReviewTiming review_timing = 7;             // Review scheduling info
  google.protobuf.Timestamp first_seen_at = 8;          // When user first encountered this word
  string notes = 9;                                     // User's personal notes
  bool is_active = 10;                                  // Soft delete flag
  google.protobuf.Timestamp created_at = 11;
  google.protobuf.Timestamp updated_at = 12;

  // Computed / expanded fields
  Voc voc_details = 20;                               // Global vocabulary entry details (if word_id exists)
  int32 total_sentences = 21;                           // Number of associated sentences
  int32 total_relations = 22;                           // Number of word relations
}

// Word-to-word relationship for building vocabulary networks
message WordRelation {
  int64 id = 1;
  int64 user_id = 2;
  int64 word_a_id = 3;                                  // Source user_word id
  int64 word_b_id = 4;                                  // Target user_word id
  common.v1.RelationType relation_type = 5;             // Type of relationship
  string subtype = 6;                                   // Additional categorization (optional)
  bool is_bidirectional = 7;                            // Whether relation works both ways
  int32 weight = 8;                                     // Relationship strength (1-100)
  string note = 9;                                      // User's note about this relation
  string created_source = 10;                           // How this relation was created (manual/auto)
  bool is_active = 11;                                  // Soft delete flag
  google.protobuf.Timestamp created_at = 12;
  google.protobuf.Timestamp updated_at = 13;

  // Read-only related word details (populated on response)
  UserWord word_a = 20;
  UserWord word_b = 21;
}