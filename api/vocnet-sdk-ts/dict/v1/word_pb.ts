// @generated by protoc-gen-es v2.9.0 with parameter "target=ts"
// @generated from file dict/v1/word.proto (package dict.v1, syntax proto3)
/* eslint-disable */

import type { GenFile, GenMessage, GenService } from "@bufbuild/protobuf/codegenv2";
import { fileDesc, messageDesc, serviceDesc } from "@bufbuild/protobuf/codegenv2";
import type { IDRequestSchema, Language, PaginationRequest, PaginationResponse, RelationType, SourceType } from "../../common/v1/types_pb";
import { file_common_v1_types } from "../../common/v1/types_pb";
import { file_google_api_annotations } from "../../google/api/annotations_pb";
import type { EmptySchema, Timestamp } from "@bufbuild/protobuf/wkt";
import { file_google_protobuf_empty, file_google_protobuf_timestamp } from "@bufbuild/protobuf/wkt";
import { file_validate_validate } from "../../validate/validate_pb";
import type { Phrase } from "./phrase_pb";
import { file_dict_v1_phrase } from "./phrase_pb";
import type { Message } from "@bufbuild/protobuf";

/**
 * Describes the file dict/v1/word.proto.
 */
export const file_dict_v1_word: GenFile = /*@__PURE__*/
  fileDesc("ChJkaWN0L3YxL3dvcmQucHJvdG8SB2RpY3QudjEivgMKBFdvcmQSCgoCaWQYASABKAMSDAoEdGV4dBgCIAEoCRIlCghsYW5ndWFnZRgDIAEoDjITLmNvbW1vbi52MS5MYW5ndWFnZRIRCgl3b3JkX3R5cGUYBCABKAkSDQoFbGVtbWEYBSABKAkSJAoJcGhvbmV0aWNzGAYgAygLMhEuZGljdC52MS5QaG9uZXRpYxIoCgtkZWZpbml0aW9ucxgHIAMoCzITLmRpY3QudjEuRGVmaW5pdGlvbhIMCgR0YWdzGAggAygJEiAKB3BocmFzZXMYCSADKAsyDy5kaWN0LnYxLlBocmFzZRIkCglzZW50ZW5jZXMYCiADKAsyES5kaWN0LnYxLlNlbnRlbmNlEiMKBWZvcm1zGB4gAygLMhQuZGljdC52MS5Xb3JkRm9ybVJlZhIoCglyZWxhdGlvbnMYHyADKAsyFS5kaWN0LnYxLldvcmRSZWxhdGlvbhIuCgpjcmVhdGVkX2F0GGQgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcBIuCgp1cGRhdGVkX2F0GGUgASgLMhouZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCIoCghQaG9uZXRpYxILCgNpcGEYASABKAkSDwoHZGlhbGVjdBgCIAEoCSJOCgpEZWZpbml0aW9uEgsKA3BvcxgBIAEoCRIMCgR0ZXh0GAIgASgJEiUKCGxhbmd1YWdlGAMgASgOMhMuY29tbW9uLnYxLkxhbmd1YWdlIi4KC1dvcmRGb3JtUmVmEgwKBHRleHQYASABKAkSEQoJd29yZF90eXBlGAIgASgJIkwKDFdvcmRSZWxhdGlvbhIMCgR3b3JkGAEgASgJEi4KDXJlbGF0aW9uX3R5cGUYAiABKA4yFy5jb21tb24udjEuUmVsYXRpb25UeXBlIlMKCFNlbnRlbmNlEgwKBHRleHQYASABKAkSJQoGc291cmNlGAIgASgOMhUuY29tbW9uLnYxLlNvdXJjZVR5cGUSEgoKc291cmNlX3JlZhgDIAEoCSI6ChFDcmVhdGVXb3JkUmVxdWVzdBIlCgR3b3JkGAEgASgLMg0uZGljdC52MS5Xb3JkQgj6QgWKAQIQASJmChBMaXN0V29yZHNSZXF1ZXN0EjAKCnBhZ2luYXRpb24YASABKAsyHC5jb21tb24udjEuUGFnaW5hdGlvblJlcXVlc3QSDgoGZmlsdGVyGAIgASgJEhAKCG9yZGVyX2J5GAMgASgJImQKEUxpc3RXb3Jkc1Jlc3BvbnNlEjEKCnBhZ2luYXRpb24YASABKAsyHS5jb21tb24udjEuUGFnaW5hdGlvblJlc3BvbnNlEhwKBXdvcmRzGAIgAygLMg0uZGljdC52MS5Xb3JkIlEKEUxvb2t1cFdvcmRSZXF1ZXN0EhUKBHdvcmQYASABKAlCB/pCBHICEAESJQoIbGFuZ3VhZ2UYAiABKA4yEy5jb21tb24udjEuTGFuZ3VhZ2UygQQKC1dvcmRTZXJ2aWNlElEKCkNyZWF0ZVdvcmQSGi5kaWN0LnYxLkNyZWF0ZVdvcmRSZXF1ZXN0Gg0uZGljdC52MS5Xb3JkIhiC0+STAhI6ASoiDS9hcGkvdjEvd29yZHMSSQoKVXBkYXRlV29yZBINLmRpY3QudjEuV29yZBoNLmRpY3QudjEuV29yZCIdgtPkkwIXOgEqGhIvYXBpL3YxL3dvcmRzL3tpZH0SSgoHR2V0V29yZBIULmNvbW1vbi52MS5JRFJlcXVlc3QaDS5kaWN0LnYxLldvcmQiGoLT5JMCFBISL2FwaS92MS93b3Jkcy97aWR9ElkKCUxpc3RXb3JkcxIZLmRpY3QudjEuTGlzdFdvcmRzUmVxdWVzdBoaLmRpY3QudjEuTGlzdFdvcmRzUmVzcG9uc2UiFYLT5JMCDxINL2FwaS92MS93b3JkcxJVCgpMb29rdXBXb3JkEhouZGljdC52MS5Mb29rdXBXb3JkUmVxdWVzdBoNLmRpY3QudjEuV29yZCIcgtPkkwIWEhQvYXBpL3YxL3dvcmRzOmxvb2t1cBJWCgpEZWxldGVXb3JkEhQuY29tbW9uLnYxLklEUmVxdWVzdBoWLmdvb2dsZS5wcm90b2J1Zi5FbXB0eSIagtPkkwIUKhIvYXBpL3YxL3dvcmRzL3tpZH1ChwEKC2NvbS5kaWN0LnYxQglXb3JkUHJvdG9QAVowZ2l0aHViLmNvbS9lc2xzb2Z0L3ZvY25ldC9hcGkvZ2VuL2RpY3QvdjE7ZGljdHYxogIDRFhYqgIHRGljdC5WMcoCB0RpY3RcVjHiAhNEaWN0XFYxXEdQQk1ldGFkYXRh6gIIRGljdDo6VjFiBnByb3RvMw", [file_common_v1_types, file_google_api_annotations, file_google_protobuf_empty, file_google_protobuf_timestamp, file_validate_validate, file_dict_v1_phrase]);

/**
 * @generated from message dict.v1.Word
 */
export type Word = Message<"dict.v1.Word"> & {
  /**
   * Auto-increment ID (CRUD only)
   *
   * @generated from field: int64 id = 1;
   */
  id: bigint;

  /**
   * Surface form (lemma or inflected/variant form)
   *
   * @generated from field: string text = 2;
   */
  text: string;

  /**
   * Language of the entry
   *
   * @generated from field: common.v1.Language language = 3;
   */
  language: Language;

  /**
   * Allowed values: lemma, past, pp (past participle), ing (present participle / gerund), 3sg (third person singular), plural, comparative, superlative, variant, derived, other
   *
   * @generated from field: string word_type = 4;
   */
  wordType: string;

  /**
   * Present only if word_type != lemma; empty when this is the lemma itself
   *
   * @generated from field: string lemma = 5;
   */
  lemma: string;

  /**
   * IPAs for this word
   *
   * @generated from field: repeated dict.v1.Phonetic phonetics = 6;
   */
  phonetics: Phonetic[];

  /**
   * Possibly multiple languages' definitions
   *
   * @generated from field: repeated dict.v1.Definition definitions = 7;
   */
  definitions: Definition[];

  /**
   * Level / topic tags
   *
   * @generated from field: repeated string tags = 8;
   */
  tags: string[];

  /**
   * Common phrases/idioms containing this word
   *
   * @generated from field: repeated dict.v1.Phrase phrases = 9;
   */
  phrases: Phrase[];

  /**
   * Example sentences
   *
   * @generated from field: repeated dict.v1.Sentence sentences = 10;
   */
  sentences: Sentence[];

  /**
   * When this entry is a lemma (word_type == "lemma"), forms lists all other surface forms
   * (e.g. past, past_participle, plural, etc.) referencing this lemma. It MUST NOT include
   * the lemma itself.
   * When this entry is a non-lemma form, forms is empty; the original lemma text can be
   * obtained from the `lemma` field. We return structured objects instead of plain strings
   * so the client knows which type each form is without extra lookups.
   *
   * @generated from field: repeated dict.v1.WordFormRef forms = 30;
   */
  forms: WordFormRef[];

  /**
   * Relationships to other words (e.g. synonyms, antonyms)
   *
   * @generated from field: repeated dict.v1.WordRelation relations = 31;
   */
  relations: WordRelation[];

  /**
   * Creation timestamp
   *
   * @generated from field: google.protobuf.Timestamp created_at = 100;
   */
  createdAt?: Timestamp;

  /**
   * Last update timestamp
   *
   * @generated from field: google.protobuf.Timestamp updated_at = 101;
   */
  updatedAt?: Timestamp;
};

/**
 * Describes the message dict.v1.Word.
 * Use `create(WordSchema)` to create a new message.
 */
export const WordSchema: GenMessage<Word> = /*@__PURE__*/
  messageDesc(file_dict_v1_word, 0);

/**
 * @generated from message dict.v1.Phonetic
 */
export type Phonetic = Message<"dict.v1.Phonetic"> & {
  /**
   * IPA transcription
   *
   * @generated from field: string ipa = 1;
   */
  ipa: string;

  /**
   * BCP-47 language tag for dialect (e.g. en-US, en-GB)
   *
   * @generated from field: string dialect = 2;
   */
  dialect: string;
};

/**
 * Describes the message dict.v1.Phonetic.
 * Use `create(PhoneticSchema)` to create a new message.
 */
export const PhoneticSchema: GenMessage<Phonetic> = /*@__PURE__*/
  messageDesc(file_dict_v1_word, 1);

/**
 * @generated from message dict.v1.Definition
 */
export type Definition = Message<"dict.v1.Definition"> & {
  /**
   * Part of speech, e.g. n., v., adj.
   *
   * @generated from field: string pos = 1;
   */
  pos: string;

  /**
   * Definition text
   *
   * @generated from field: string text = 2;
   */
  text: string;

  /**
   * Language of the translation
   *
   * @generated from field: common.v1.Language language = 3;
   */
  language: Language;
};

/**
 * Describes the message dict.v1.Definition.
 * Use `create(DefinitionSchema)` to create a new message.
 */
export const DefinitionSchema: GenMessage<Definition> = /*@__PURE__*/
  messageDesc(file_dict_v1_word, 2);

/**
 * Minimal reference for an inflected / variant form; no id to keep payload light.
 *
 * @generated from message dict.v1.WordFormRef
 */
export type WordFormRef = Message<"dict.v1.WordFormRef"> & {
  /**
   * The surface form text
   *
   * @generated from field: string text = 1;
   */
  text: string;

  /**
   * The specific form type (same value domain as Word.word_type)
   *
   * @generated from field: string word_type = 2;
   */
  wordType: string;
};

/**
 * Describes the message dict.v1.WordFormRef.
 * Use `create(WordFormRefSchema)` to create a new message.
 */
export const WordFormRefSchema: GenMessage<WordFormRef> = /*@__PURE__*/
  messageDesc(file_dict_v1_word, 3);

/**
 * Word-to-word relationship for building vocabulary networks
 *
 * @generated from message dict.v1.WordRelation
 */
export type WordRelation = Message<"dict.v1.WordRelation"> & {
  /**
   * @generated from field: string word = 1;
   */
  word: string;

  /**
   * Type of relationship
   *
   * @generated from field: common.v1.RelationType relation_type = 2;
   */
  relationType: RelationType;
};

/**
 * Describes the message dict.v1.WordRelation.
 * Use `create(WordRelationSchema)` to create a new message.
 */
export const WordRelationSchema: GenMessage<WordRelation> = /*@__PURE__*/
  messageDesc(file_dict_v1_word, 4);

/**
 * @generated from message dict.v1.Sentence
 */
export type Sentence = Message<"dict.v1.Sentence"> & {
  /**
   * Surface form of the sentence
   *
   * @generated from field: string text = 1;
   */
  text: string;

  /**
   * How this sentence was added
   *
   * @generated from field: common.v1.SourceType source = 2;
   */
  source: SourceType;

  /**
   * Optional reference (book or article title)
   *
   * @generated from field: string source_ref = 3;
   */
  sourceRef: string;
};

/**
 * Describes the message dict.v1.Sentence.
 * Use `create(SentenceSchema)` to create a new message.
 */
export const SentenceSchema: GenMessage<Sentence> = /*@__PURE__*/
  messageDesc(file_dict_v1_word, 5);

/**
 * CreateWord request (creates either a lemma entry or a derived/inflected form)
 *
 * @generated from message dict.v1.CreateWordRequest
 */
export type CreateWordRequest = Message<"dict.v1.CreateWordRequest"> & {
  /**
   * @generated from field: dict.v1.Word word = 1;
   */
  word?: Word;
};

/**
 * Describes the message dict.v1.CreateWordRequest.
 * Use `create(CreateWordRequestSchema)` to create a new message.
 */
export const CreateWordRequestSchema: GenMessage<CreateWordRequest> = /*@__PURE__*/
  messageDesc(file_dict_v1_word, 6);

/**
 * ListWords request
 *
 * @generated from message dict.v1.ListWordsRequest
 */
export type ListWordsRequest = Message<"dict.v1.ListWordsRequest"> & {
  /**
   * @generated from field: common.v1.PaginationRequest pagination = 1;
   */
  pagination?: PaginationRequest;

  /**
   * filtering options using CEL expressions
   *
   * @generated from field: string filter = 2;
   */
  filter: string;

  /**
   * ordering options. e.g. "word asc", "mastery.overall desc"
   *
   * @generated from field: string order_by = 3;
   */
  orderBy: string;
};

/**
 * Describes the message dict.v1.ListWordsRequest.
 * Use `create(ListWordsRequestSchema)` to create a new message.
 */
export const ListWordsRequestSchema: GenMessage<ListWordsRequest> = /*@__PURE__*/
  messageDesc(file_dict_v1_word, 7);

/**
 * @generated from message dict.v1.ListWordsResponse
 */
export type ListWordsResponse = Message<"dict.v1.ListWordsResponse"> & {
  /**
   * @generated from field: common.v1.PaginationResponse pagination = 1;
   */
  pagination?: PaginationResponse;

  /**
   * @generated from field: repeated dict.v1.Word words = 2;
   */
  words: Word[];
};

/**
 * Describes the message dict.v1.ListWordsResponse.
 * Use `create(ListWordsResponseSchema)` to create a new message.
 */
export const ListWordsResponseSchema: GenMessage<ListWordsResponse> = /*@__PURE__*/
  messageDesc(file_dict_v1_word, 8);

/**
 * LookupWordRequest performs an exact text lookup in specified language (default en)
 *
 * @generated from message dict.v1.LookupWordRequest
 */
export type LookupWordRequest = Message<"dict.v1.LookupWordRequest"> & {
  /**
   * @generated from field: string word = 1;
   */
  word: string;

  /**
   * optional; if unspecified, server default language
   *
   * @generated from field: common.v1.Language language = 2;
   */
  language: Language;
};

/**
 * Describes the message dict.v1.LookupWordRequest.
 * Use `create(LookupWordRequestSchema)` to create a new message.
 */
export const LookupWordRequestSchema: GenMessage<LookupWordRequest> = /*@__PURE__*/
  messageDesc(file_dict_v1_word, 9);

/**
 * @generated from service dict.v1.WordService
 */
export const WordService: GenService<{
  /**
   * Create a new wordabulary entry (admin/system use)
   *
   * @generated from rpc dict.v1.WordService.CreateWord
   */
  createWord: {
    methodKind: "unary";
    input: typeof CreateWordRequestSchema;
    output: typeof WordSchema;
  },
  /**
   * Update a wordabulary entry by id (admin/system use)
   *
   * @generated from rpc dict.v1.WordService.UpdateWord
   */
  updateWord: {
    methodKind: "unary";
    input: typeof WordSchema;
    output: typeof WordSchema;
  },
  /**
   * Get wordabulary entry details by id or composite key
   *
   * @generated from rpc dict.v1.WordService.GetWord
   */
  getWord: {
    methodKind: "unary";
    input: typeof IDRequestSchema;
    output: typeof WordSchema;
  },
  /**
   * List wordabulary entries with filtering and pagination
   *
   * @generated from rpc dict.v1.WordService.ListWords
   */
  listWords: {
    methodKind: "unary";
    input: typeof ListWordsRequestSchema;
    output: typeof ListWordsResponseSchema;
  },
  /**
   * Lookup wordabulary entry by exact text match in specified language
   *
   * @generated from rpc dict.v1.WordService.LookupWord
   */
  lookupWord: {
    methodKind: "unary";
    input: typeof LookupWordRequestSchema;
    output: typeof WordSchema;
  },
  /**
   * Delete a wordabulary entry by id (admin/system use)
   *
   * @generated from rpc dict.v1.WordService.DeleteWord
   */
  deleteWord: {
    methodKind: "unary";
    input: typeof IDRequestSchema;
    output: typeof EmptySchema;
  },
}> = /*@__PURE__*/
  serviceDesc(file_dict_v1_word, 0);

